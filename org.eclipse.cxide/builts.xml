<?xml version="1.0" encoding="UTF-8"?>
<predicates>
<pred>
        <id>pwd</id>
</pred>

<pred>
        <id>pop</id>
        <desc>pop
    Pops the current context. Therefore restores the
    previous current unit, which will be used in
    the top-level iteration</desc>
</pred>

<pred>
        <id>push(+U)</id>
        <desc>push +U
    Pushes the unit designator U on top of current
    context. Therefore changes the current unit
    to be used in the top-level iteration.</desc>
</pred>

<pred>
        <id>foreigns</id>
        <desc>foreigns 
        Shows the foreign interfaces available in the current building
    of CxProlog.</desc>
</pred>	

<pred>
        <id>gui_event_discard_all</id>
</pred>

<pred>
        <id>gui_event_is_available</id>
</pred>

<pred>
        <id>gui_event_get(_G2176)</id>
</pred>

<pred>
        <id>ztest</id>
</pred>

<pred>
        <id>:::</id>
        <desc>
GTest ::: GExpected
    GTest is the goal being tested and GExpected is a simpler goal that
    describes the expected effects of GTest. If GTest does not match
    GExpected in terms of RESULT or OUTPUT, then a written report is generated.
    As for the RESULT, there are three possible RESULTS from testing a
    goal: success, failure and exception. As for the OUTPUT, the output
    used in the comparison is the output sent to the current output
    stream.
    Some examples. Here are some unit test in which GTest matches
    GExpected - so no reports are generated in these cases::

      :- X=1 ::: true.
      :- 1==2 ::: fail.
      :- see(nosuchfile) ::: throw(_).
      :- X=1, writeln(X), X==2 ::: writeln(1), fail.

GTest ::: GExpected &lt;&lt;: GGuard
    The predicate &lt;&lt;:/2 allows a guard to be placed at the end of a unit
    test, so that a unit test is run conditionally.</desc>
</pred>

<pred>
        <id>&lt;&lt;:</id>
        <desc>GTest ::: GExpected &lt;&lt;: GGuard
    The predicate &lt;&lt;:/2 allows a guard to be placed at the end of a unit
    test, so that a unit test is run conditionally.
        </desc>
</pred>

<pred>
        <id>^</id>
        <desc>+E1 ^ +E2
    The same as E1 ** E2.</desc>
</pred>

<pred>
        <id>?-</id>
</pred>

<pred>
        <id>portray_clause(_G2151)</id>
</pred>

<pred>
        <id>listing(+A,+N)</id>
        <desc>listing(+A/+N)
    Lists the declarations and clauses in the current unit
    that are concerned with the predicate A/N.</desc>
</pred>

<pred>
        <id>listing(+A)</id>
        <desc>listing(+A)
    Lists the declarations and clauses in the current unit
    that are concerned with all the predicates named A</desc>
</pred>

<pred>
        <id>listing</id>
        <desc>
listing
    Lists the declarations and clauses in current unit.</desc>
</pred>

<pred>
        <id>list</id>
        <desc>
	list
    Same as listing.</desc>
</pred>

<pred>
        <id>all</id>
        <desc>all
    Lists the contents of all the existing units.</desc>
</pred>

<pred>
        <id>question(+G,+L)</id>
        <desc>question(+G,+L)
    Implements the top-level queries of the predefined
    top-level user-iteration. Also implements the *?-G*
    questions inside the consulting predicates.</desc>
</pred>

<pred>
        <id>hidden(_G2127)</id>
</pred>

<pred>
        <id>xover(_G2123)</id>
</pred>

<pred>
        <id>xnew(_G2119)</id>
</pred>

<pred>
        <id>:-</id>
</pred>

<pred>
        <id>silent_reconsult(+F)</id>
        <desc>silent_reconsult(+F)
    Only available if the Prolog flag 'old_update' is 'true'. Reconsults
    the file or list of files specified by F. Behaves like
    reconsult/1 except that produces no statistics.</desc>
</pred>

<pred>
        <id>ensure_loaded(+F)</id>
        <desc>ensure_loaded(+F) [ISO]
    Consults the file or list of files specified by F, but ignores
    the files that have already been loaded. Therefore, is equivalent
    to consult/1 for the files that have not been loaded yet.</desc>
</pred>

<pred>
        <id>compile(+F)</id>
        <desc>compile(+F)
    The same as consult(F).</desc>
</pred>

<pred>
        <id>consult(+F)</id>
        <desc>consult(+F) [ISO]
    Consults the file F or list of files F, writing some statistics
    and emitting some warnings, if necessary. The argument F
    represents an atom or a list of atoms. The consulted files may
    contain directives :-/1 or ?-/1. This predicate is ISO-compatible.
    It assumes that the entire definition of each predicate is
    contained in a single file. If it comes across, in a different
    file, of more clauses for an already loaded predicate, it redefines
    the predicate using the new clauses and issues a warning. Only
    predicates with the property 'multifile' are allowed to be defined
    across multiple files.
    It also assumes that the entire definition of each predicate is
    made of contiguous clauses in each file. A warning is issued for
    predicates made of discontiguous clauses. Only predicates with the
    property 'discontiguous' are allowed to be defined using discontiguous
    clauses.
    The consult predicate remembers the source file of each clause and
    uses this source file information whenever the same file is about to
    be consulted one more time: in preparation for the new definitions
    it removes from the database all the old clauses, previously sourced
    at that file (except if the file being consulted is 'user' or
    'user_input').
    By using consult/1 in strange ways, e.g. "a(2):-[file],fail.", a static
    predicate can change itself while running. In such a case, the
    implementation enforces the "logical update semantic view", even
    with static predicates.

    The Prolog flag 'old_update' changes the semantics of the consulting
    predicates (and also of the assert and retract predicates) to support
    compatibility with the old C-Prolog and retro-compatibility with
    versions of CxProlog prior to 0.92: more details in the section
    'Prolog Flags'.

    HOW TO WRITE YOUR OWN CONSULT PREDICATE: If you want to write your
    own ISO-compatible consult predicate, you need to use the
    unofficial unsafe predicate '$consult_clause'/1 which supports adding
    new clauses to the end of any user predicate even if it is a static
    predicate; note that'$consult_clause'/1 provides consistent update
    semantics only if the target predicate is being built or rebuilt from
    scratch, at it always happens in consult/1. You may also take advantage
    of the standard consult management of the Prolog database
    by calling '$enter_consult'(S) near the beginning of your consult
    predicate and '$exit_consult' near its ending. Finally, to process
    the directives in the standard way, you may also want to call
    '$consult_directive'(G) whenever you come across a directive :-G.
    Here is the generic scheme of a user defined consult predicate::

         myconsult(File) :-
            ( File == user -> S = user ; open(File,read,S) ),
            '$enter_consult'(S),
            myconsult_loop(S),   % uses '$consult_clause'/1 and
            '$exit_consult',     %              '$consult_directive'/1
            close(S).</desc>
</pred>

<pred>
        <id>reconsult(+F)</id>
        <desc>
reconsult(+F)
    Only available if the Prolog flag 'old_update' is 'true'. Reconsults the
    file F in the style of the old C-Prolog. Also writes some statistics
    to user_output.</desc>
</pred>

<pred>
        <id>[Head|Tail]</id>
</pred>

<pred>
        <id>[]</id>
</pred>

<pred>
        <id>add_pl(+A1,-A2)</id>
        <desc>add_pl(+A1,-A2)
    A2 is the concatenation of A1 with '.pl' unless this
    extension is already in A1. Another exception is
    the atom 'user', which remains unchanged.</desc>
</pred>

<pred>
        <id>gensym(-Unique)</id>
        <desc>gensym(-Unique)
    Generates unique atoms with the prefix '%'. Successive invocations
    will generate '%1', '%2', '%3', ...</desc>
</pred>

<pred>
        <id>gensym(+Prefiz,-Unique)</id>
        <desc>gensym(+Prefix,-Unique)
    Generates unique atoms with the given prefix. For example, successive
    invocations of gensym(a,X) will return a1, a2, a3, ... This is a
    relatively standard predicate, supported for C-Prolog, SWI-Prolog, etc.</desc>
</pred>

<pred>
        <id>bagof(+T,+G,-L)</id>
        <desc>
bagof(+T,+G,-L) [ISO]
    L is unified with the list (not ordered an possibly
    containing duplicates) of all the instances of template
    T for which G is provable. The predicate fails if G
    fails for every instance of T. If G is of the form
    *X^T*, where X is a variable, then X is treated as being
    existentially quantified in T. G must not be an
    uninstantiated variable.</desc>
</pred>

<pred>
        <id>setof(+T,+G,-L)</id>
        <desc>setof(+T,+G,-L) [ISO]
    Like bagof except that the returned list L is free from
    duplicates.</desc>
</pred>

<pred>
        <id>findall(+T,+G,-L)</id>
        <desc>findall(+T,+G,-L) [ISO]
    L is unified with the list (not ordered an possibly
    containing duplicates) of all the instances of template
    T for which G is provable. All free variable
    (those contained in G and not in T) are considered
    to be existentially quantified.</desc>
</pred>

<pred>
        <id>retractall(+T)</id>
        <desc>retractall(+T) [ISO]
    Erases from the current unit all the clauses with heads matching T.
    All the erased clauses must belong to the same dynamic predicate.</desc>
</pred>

<pred>
        <id>forall(+G1,+G2)</id>
        <desc>forall(+G1, +G2)
    Checks whether the goal G2 can be proved for all the alternative
    bindings of a goal G1. Defined as:
    *forall(G1, G2) :- \+ (G1, \+ G2).*</desc>
</pred>

<pred>
        <id>app(?L1,?L2,?L3)</id>
        <desc>app(?L1,?L2,?L3)
    Append lists.</desc>
</pred>

<pred>
        <id>silent_consult(+F)</id>
        <desc>silent_consult(+F)
    Consults the file or list of files specified by F. Behaves like
    consult/1 except that produces no statistics neither warnings.</desc>
</pred>

<pred>
        <id>current_op(-Prec,-Type,-Name)</id>
        <desc>current_op(-Prec,-Type,-Name) [ISO]
    Provides read-only access to the internal operator table.
    Can also be used to generate, through backtracking, all
    the existing operators.</desc>
</pred>

<pred>
        <id>show_hcontext(+S)</id>
        <desc>
show_hcontext(+S)
    Displays the current historic context on the output
    stream S.</desc>
</pred>

<pred>
        <id>show_hcontext</id>
        <desc>
show_hcontext
    Displays the current historic context on the current
    output stream.
        </desc>
</pred>

<pred>
        <id>import</id>
        <desc>(import _G2022)</desc>
</pred>

<pred>
        <id>call_on_context(_G2017,_G2018)</id>
        <desc>call_on_context(+L,+G)
    Context setting. Proves G in a given context L,
    represented as a list of unit designators.</desc>
</pred>

<pred>
        <id>show_context(+S)</id>
        <desc>show_context(+S)
    Displays the current context on the output stream S.</desc>
</pred>

<pred>
        <id>show_context</id>
        <desc>Displays the current context on the current output
    stream.</desc>
</pred>

<pred>
        <id>unit_arity(-N)</id>
        <desc>unit_arity(-N)
    N is the arity of the current unit.</desc>
</pred>

<pred>
        <id>unit_param(+N,-T)</id>
        <desc>unit_param(+N,-T)
    T is the value of the N-th parameter of the current unit.</desc>
</pred>

<pred>
        <id>context_top(-U)</id>
        <desc>context_top(-U)
    U is the top of the current context. This is a
    unit designator corresponding to the current unit.</desc>
</pred>

<pred>
        <id>zpf</id>
</pred>

<pred>
        <id>trace</id>
        <desc>trace
    Switches "trace mode" on. The debugger will
    trace the execution of the first encountered
    non built-in predicate (even if it has not a
    spy point set. This allows exhaustive
    tracing of a program. Equivalent to
    *set_prolog_flag(debug,2).*</desc>
</pred>

<pred>
        <id>debug</id>
        <desc>
debug
    Switches "debug mode" on. The debugger will
    trace the execution of the first encountered
    predicate with a spy point set. Equivalent to
    *set_prolog_flag(debug,1).*</desc>
</pred>

<pred>
        <id>notrace</id>
        <desc>notrace
    Same as nodebug/0.</desc>
</pred>

<pred>
        <id>nodebug</id>
        <desc>nodebug
    Switches debug mode off and removes all spy points.
    Equivalent to *set_prolog_flag(debug,0).*</desc>
</pred>

<pred>
        <id>mutable_builtin(+A,+N)</id>
        <desc>mutable_builtin(+A,+N) [deprecated]
    Exists for backward compatibility. Now the prefered method
    of creating a mutable built-in is simply declaring it
    as 'dynamic' at boot time. The *:- mutable_builtin(A,N)*
    or *:- dynamic A/N* declarations must precede the clauses
    of the predicate. Note that built-ins are immutable by default.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    programmer who wants to create an "ALTERNATIVE BOOT FILE".</desc>
</pred>

<pred>
        <id>system_predicate(?Head)</id>
        <desc>system_predicate(?Head)
    Exists for backward compatibility with old versions of CxProlog.
    Defined as:
      system_predicate(Head) :- predicate_property(Head, built_in).</desc>
</pred>

<pred>
        <id>builtin_predicate(?Head)</id>
        <desc>builtin_predicate(?Head)
    Exists for backward compatibility with old versions of CxProlog.
    Defined as:
      builtin_predicate(Head) :- predicate_property(Head, built_in).</desc>
</pred>

<pred>
        <id>imported_predicate(?Head,?U)</id>
        <desc>imported_predicate(?Head,?U)
    Exists for backward compatibility. Defined as:
      imported_predicate(Head,U) :- predicate_property(Head, imported_from(U)).</desc>
</pred>

<pred>
        <id>visible_predicate(?Head)</id>
        <desc>visible_predicate(?Head)
    Exists for backward compatibility. Defined as:
      visible_predicate(P) :- predicate_property(Head, visible).</desc>
</pred>

<pred>
        <id>check_globals</id>
</pred>

<pred>
        <id>check_imports</id>
        <desc>check_imports
    Produces warnings concerning the inconsistency of
    the import/visibility declarations. Examples:

    - "Predicate A/N is imported from non-existent unit U".
    - "Imported predicate A/N is not visible in unit U".</desc>
</pred>

<pred>
        <id>check_missing</id>
        <desc>check_missing
    Produces warnings concerning missing predicates,
    invoked in existing code. Sometimes they will be
    legitimate "context dependent predicates".
    Sometimes they will be genuine mistakes that must
    be corrected.</desc>
</pred>

<pred>
        <id>(+T1:-+T2)</id>
            <desc>+T1 :- +T2
    Handy predicate for asserting clauses at the top
    level. Equivalent to assertz((+T1 :- +T2)).</desc>
</pred>

<pred>
        <id>=..</id>
        <desc>?T =.. ?L [ISO]
    Univ. L is the list whose head is the atom
    corresponding to the principal functor of T and
    whose tail is the list of arguments of T.</desc>
</pred>

<pred>
        <id>with_ivar(+A,+T,+G)</id>
        <desc>with_ivar(+A,+T,+G)
    Proves goal G with the ivar A temporarily set to term T.
    Here is an approximate definition:
    *with_ivar(A,T,G) :- A =: X, A &amp;:= T, G, A &amp;:= X.*
    The real version also deals with cuts and with the
    case A is undefined.</desc>
</pred>

<pred>
        <id>possible(+G)</id>
        <desc>
possible +G
    Succeeds deterministically if and only if there is at
    least one solution to G. The current instantiation
    state of G is not changed. Except for occurrence of
    cuts in G, the predicate could be defined as:
    *possible G :- \\+ \\+ G.*</desc>
</pred>

<pred>
        <id>gen(+G)</id>
        <desc>gen +G
    Explores all the alternatives in the goal G and, at
    the end, succeeds with the current instantiation
    state of G unchanged. Except for occurrence of cuts
    in G, this predicate could be defined as:
    *gen G :- G, fail ; true.*</desc>
</pred>

<pred>
        <id>not(+G)</id>
        <desc>not +G
    	Same as *\\+ G*.</desc>
</pred>

<pred>
        <id>\+_G1928</id>
        <desc>\+G [ISO]
    	Same as call(+G).
        </desc>
</pred>

<pred>
        <id>exit_script_fast</id>
</pred>

<pred>
        <id>exit_script</id>
        <desc>exit_script
    Acts like exit/0 inside scripts and like true/0 outside scripts.
    This predicate checks if there is a script running by simply
    looking for the '--script' argument in the the command line.</desc>
</pred>

<pred>
        <id>is_script(_G1920)</id>
</pred>

<pred>
        <id>try _G1916</id>
        <desc>try +G
    Always succeeds deterministically, either with the first
    solution for G, if one exists, or otherwise with G
    unchanged. Except for the occurrence of cuts in G,
    this predicate could be defined as:
    *try G :- G, ! ; true.*</desc>
</pred>

<pred>
        <id>once +G</id>
        <desc>once +G [ISO]
    Succeeds deterministically with the first solution to G
    if and only if there exists at least one. Except for
    the occurrence of cuts in G, this predicate could be
    defined as:
    *once G :- G, !.*</desc>
</pred>

<pred>
        <id>set_result(_G1908)</id>
</pred>

<pred>
        <id>copyright</id>
</pred>

<pred>
        <id>version(-A)</id>
        <desc>version(-A)
    Gets the identification of the running version of CxProlog.</desc>
</pred>

<pred>
        <id>version</id>
        <desc>version
    	Show the identification of the current version
    	of CxProlog.</desc>
</pred>

<pred>
        <id>os_args(_G1896)</id>
        <desc>os_args(-L)
   		 Gets the entire command-line as a list of atoms.
    	Example: os_args(X)</desc>
</pred>

<pred>
        <id>os_arg(_G1891,_G1892)</id>
        <desc>os_arg(+A,-Ar)
    Gets the argument corresponding to an individual command-line option A.
    The option A must be an atom starting with a hyphen. If there is no
    option named A in the command-line then the predicate fails. Otherwise,
    if there is no argument corresponding to that option then Ar=''.
    Example: os_arg('--boot',X)</desc>
</pred>

<pred>
        <id>consulting(-S)</id>
        <desc>consulting(-S)
    Obtains the input stream currently being consulted (or included).
    This predicate is intended to be used in the directives
    :-/1 or ?-/1 occurring in the stream being consulted.
    The predicate fails if no consulting is taking place.</desc>
</pred>

<pred>
        <id>load_lib</id>
</pred>

<pred>
        <id>features</id>
        <desc>features
    Prints information about certain features of CxProlog that
    may vary between installations.</desc>
</pred>

<pred>
        <id>show</id>
        <desc>show
    Synopsis of the available "show predicates", which
    are predicates that show certain details of
    the CxProlog internal state.</desc>
</pred>

<pred>
        <id>os_name(-A)</id>
        <desc>os_name(-A)
    Gets the name of the underlying operating system.
    As yet, the possible results are:
    'unix', 'win32', 'unknown'</desc>
</pred>

<pred>
        <id>loud_end_of_file</id>
</pred>

<pred>
        <id>end_of_file</id>
</pred>

<pred>
        <id>os_tid(_G1869)</id>
        <desc>
	os_tid(-N)
    Gets the current thread ID.</desc>
</pred>

<pred>
        <id>os_ppid(_G1865)</id>
       
</pred>

<pred>
        <id>os_pid(_G1861)</id>
        <desc>os_pid(-N)
    Gets the current process ID.</desc>
</pred>

<pred>
        <id>os_sleep(_G1857)</id>
</pred>

<pred>
        <id>os_env(_G1852,_G1853)</id>
        <desc>os_env(+A,-Ar)
    Accesses environment variables.
    Example: os_env('PATH',X)</desc>
</pred>

<pred>
	<id>sh</id>
	<desc>C-Prolog compatibly predicate. Identical to os_run('sh').</desc>
</pred>

<pred>
        <id>system(_G1846)</id>
        <desc>system(+A)
    C-Prolog compatibly predicate. Identical to os_run/1</desc>
</pred>

<pred>
        <id>os_run(+A)</id>
        <desc>os_run(+A)
    Runs command A. Succeeds in case of successful
    command completion.</desc>
</pred>

<pred>
        <id>processes</id>
        <desc>processes
    Shows all the child processes.</desc>
</pred>

<pred>
        <id>current_process(?P)</id>
        <desc>current_process(?P)
    Generates, through backtracking, all the existing child processes.</desc>
</pred>

<pred>
        <id>process_receive_from_child_ready</id>
        <desc>process_receive_from_child_ready
    Non-blocking primitive that checks whether or not
    there is a message available.</desc>
</pred>

<pred>
        <id>process_receive_from_child(-P,-N)</id>
        <desc>
process_receive_from_child(-P,-N)
    Father receives message N from its child process P.
    This is a blocking primitive: if there is no message
    available, the father waits. N is a non-negative integer.</desc>
</pred>

<pred>
        <id>process_send_father_max(-N)</id>
        <desc>process_send_father_max(-N)
    N is the number of consecutive sends that puts
    the system in a dead-lock state, if the father
    never reads the messages.</desc>
</pred>

<pred>
        <id>process_send_father(+N)</id>
        <desc>process_send_father(+N)
    Child sends message N to its father.
    N is a non-negative integer</desc>
</pred>

<pred>
        <id>process_new(-P,+Goal,+RestartGoal)</id>
        <desc>process_new(-P, +Goal, +RestartGoal)
    Creates a new child process P. Goal is the startup goal.
    RestartGoal is the goal that is activated
    in case of error or explicit abort/0 call.</desc>
</pred>

<pred>
        <id>process(+P)</id>
        <desc>process(+P)
   		 P is a process.</desc>
</pred>

<pred>
        <id>net_get_int(_G1806,_G1807)</id>
</pred>

<pred>
        <id>net_put_int(_G1801,_G1802)</id>
</pred>

<pred>
        <id>net_connect(+A,+N,-S1,-s2)</id>
        <desc>net_connect(+A,+N,-S1,-S2)
    Connects, as a client, to the server A, port N, and
    open two streams to handle the communication.
    S1 is the input stream where the replies arrive.
    S2 is the output stream to where the requests are sent.</desc>
</pred>

<pred>
        <id>net_accept(-S1,-S2)</id>
        <desc>net_accept(-S1,-S2)
    On the server side, waits for the next incoming connection
    and then opens 2 streams for handling the communication.
    S1 is the input stream where the requests arrive.
    S2 is the output stream to where the replies are sent.</desc>
</pred>

<pred>
        <id>net_uninstall</id>
        <desc>net_uninstall
    Closes the local server socket.</desc>
</pred>

<pred>
        <id>net_install(+N)</id>
        <desc>net_install(+N)
    Activates a local server socket listening to port N.
    Only one server per process is supported.</desc>
</pred>

<pred>
        <id>buffers</id>
        <desc>buffers
    Shows all existing buffers.</desc>
</pred>

<pred>
        <id>current_buffer(?B)</id>
        <desc>
	current_buffer(?B)
    Generates, through backtracking, all the existing buffers.</desc>
</pred>

<pred>
        <id>buffer_write(+S,+B)</id>
        <desc>buffer_write(+S,+B)
    Writes info about B to the stream S.</desc>
</pred>

<pred>
        <id>buffer_write(+B)</id>
        <desc>buffer_write(+B)
    Writes info about B to the current output stream.</desc>
</pred>

<pred>
        <id>buffer_as_atom(_G1763,_G1764)</id>
</pred>

<pred>
        <id>buffer_get(+B,+Idx,-N)</id>
        <desc>buffer_get(+B,+Idx,-N)
    Gets N associated with Idx in buffer B. Never fails as
    all non assigned positions implicitly have the value zero.</desc>
</pred>

<pred>
        <id>buffer_set(+B,+Idx,+N)</id>
        <desc>buffer_set(+B,+Idx,+N)
    Associates the value N with index Idx in buffer B.</desc>
</pred>

<pred>
        <id>buffer_size(+B,-No,+Nn)</id>
        <desc>buffer_size(+B,-No,+Nn)
    Queries and changes the size of the buffer B. The old size
    is No and the new size is Nn. The size of the buffer is
    managed automatically, but you may need to truncate a
    portion at the end.
        </desc>
</pred>

<pred>
        <id>buffer_delete(+B)</id>
        <desc>buffer_delete(+B)
    Deletes the buffer B.</desc>
</pred>

<pred>
        <id>buffer_clear(+B)</id>
        <desc>buffer_clear(+B)
    Clears the buffer B.</desc>
</pred>

<pred>
        <id>buffer_new(-B)</id>
        <desc>
	buffer_new(-B)
    Creates a new buffer B.</desc>
</pred>

<pred>
        <id>buffer(+B)</id>
        <desc>buffer(+B)
    B is a buffer.</desc>
</pred>

<pred>
        <id>arrays</id>
        <desc>arrays
    Shows all existing arrays.
        </desc>
</pred>

<pred>
        <id>current_array(?D)</id>
        <desc>current_array(?D)
    Generates, through backtracking, all the existing arrays.</desc>
</pred>

<pred>
        <id>array_write(+S,+D)</id>
        <desc>array_write(+S,+D)
    Writes info about D to the stream S.</desc>
</pred>

<pred>
        <id>array_write(+D)</id>
        <desc>array_write(+D)
    Writes info about D to the current output stream.</desc>
</pred>

<pred>
        <id>array_as_list(+D,-L)</id>
        <desc>array_as_list(+D,-L)
    Converts the array D to a list L of Idx-T pairs.</desc>
</pred>

<pred>
        <id>array_delete_item(+D,+Idx)</id>
        <desc>array_delete_item(+D,+Idx)
    Deletes the term at Idx from the array D.</desc>
</pred>

<pred>
        <id>array_get(+D,+Idx,-T)</id>
        <desc>array_get(+D,+Idx,-T)
    Gets T associated with Idx in array D. Fails if there
    is no term associated with index Idx in D.</desc>
</pred>

<pred>
        <id>array_set(+D,+Idx,?T)</id>
        <desc>array_set(+D,+Idx,?T)
    Associates the term T with the index Idx in the
    array D.</desc>
</pred>

<pred>
        <id>array_delete(+D)</id>
        <desc>array_delete(+D)
    Deletes the array D.</desc>
</pred>

<pred>
        <id>array_clear(+D)</id>
        <desc>array_clear(+D)
    Clears the array D.</desc>
</pred>

<pred>
        <id>array_new(-D)</id>
        <desc>array_new(-D)
    Creates a new array D.</desc>
</pred>

<pred>
        <id>array(+D)</id>
        <desc>array(+D)
    D is a array.</desc>
</pred>

<pred>
        <id>dicts</id>
        <desc>dicts
    Shows all existing dictionaries.</desc>
</pred>

<pred>
        <id>current_dict(?D)</id>
        <desc>current_dict(?D)
    Generates, through backtracking, all the existing dicts.</desc>
</pred>

<pred>
        <id>dict_write(+S,+D)</id>
        <desc>
	dict_write(+S,+D)
    Writes info about D to the stream S.</desc>
</pred>

<pred>
        <id>dict_write(+D)</id>
        <desc>  dict_write(+D)
    Writes info about D to the current output stream.</desc>
</pred>

<pred>
        <id>dict_as_list(+D,-L)</id>
        <desc>dict_as_list(+D,-L)
    Converts the dictionary D to a list L of K-T pairs.</desc>
</pred>

<pred>
        <id>dict_delete_item(+D,+Key)</id>
        <desc>dict_delete_item(+D,+Key)
    Deletes the key Key from the dictionary D.</desc>
</pred>

<pred>
        <id>dict_get(+D,+Key,-T)</id>
        <desc>
	dict_get(+D,+Key,-T)
    Gets T associated with Key in dictionary D.</desc>
</pred>

<pred>
        <id>dict_set(+D,+Key,?T)</id>
        <desc>dict_set(+D,+Key,?T)
    Associates the term T with the key Key in the
    dictionary D.</desc>
</pred>

<pred>
        <id>dict_delete(+D)</id>
        <desc>dict_delete(+D)
    Deletes the dict D.</desc>
</pred>

<pred>
        <id>dict_clear(+D)</id>
        <desc>dict_clear(+D)
    Clears the dict D.</desc>
</pred>

<pred>
        <id>dict_new(_G1627)</id>
        <desc>dict_new(-D)
    Creates a new dictionary D.</desc>
</pred>

<pred>
        <id>dict(+D)</id>
        <desc>D is a dict</desc>
</pred>

<pred>
        <id>stacks</id>
        <desc>stacks
    Shows all existing stacks.</desc>
</pred>

<pred>
        <id>current_stack(?K)</id>
        <desc>
current_stack(?K)
    Generates, through backtracking, all the existing stacks.</desc>
</pred>

<pred>
        <id>stack_write(+S,+K)</id>
        <desc>stack_write(+S,+K)
    Writes info about K to the stream S.</desc>
</pred>

<pred>
        <id>stack_write(+K)</id>
        <desc>stack_write(+K)
    Writes info about K to the current output stream.</desc>
</pred>

<pred>
        <id>stack_as_list(+K,-L)</id>
        <desc>stack_as_list(+K,-L)
    Converts the stack K to a list L of terms.</desc>
</pred>

<pred>
        <id>stack_top(+K,-T)</id>
        <desc>
	stack_top(+K,-T)
    Examines the top of the stack K.
        </desc>
</pred>

<pred>
        <id>stack_pop(+K,-T)</id>
        <desc>stack_pop(+K,-T)
    Pops term T from the stack K.</desc>
</pred>

<pred>
        <id>stack_push(+K,?T)</id>
        <desc>stack_push(+K,?T)
    Pushes the term T on the stack K.</desc>
</pred>

<pred>
        <id>stack_delete(+K)</id>
        <desc>stack_delete(+K)
    Deletes the stack K.</desc>
</pred>

<pred>
        <id>stack_clear(+K)</id>
        <desc>stack_clear(+K)
    Clears the stack K.</desc>
</pred>

<pred>
        <id>stack_new(-K)</id>
        <desc>stack_new(-K)
   	 Creates a new stack K.</desc>
</pred>

<pred>
        <id>stack(+K)</id>
        <desc>stack(+K)
   		 K is a stack.
        </desc>
</pred>

<pred>
        <id>queues</id>
        <desc>queues
    Shows all existing queues.</desc>
</pred>

<pred>
        <id>current_queue(?Q)</id>
        <desc>current_queue(?Q)
    Generates, through backtracking, all the existing queues.</desc>
</pred>

<pred>
        <id>queue_write(+S,+Q)</id>
        <desc>queue_write(+S,+Q)
    Writes info about Q to the stream S.</desc>
</pred>

<pred>
        <id>queue_write(+Q)</id>
        <desc>queue_write(+Q)
    Writes info about Q to the current output stream.</desc>
</pred>

<pred>
        <id>queue_as_seq(+Q,-L)</id>
        <desc>queue_as_seq(+Q,-L)
    Converts the queue Q to a Sequence L of terms.</desc>
</pred>

<pred>
        <id>queue_as_list(+Q,-L)</id>
        <desc>queue_as_list(+Q,-L)
    Converts the queue Q to a list L of terms.</desc>
</pred>

<pred>
        <id>queue_peek(+Q,-T)</id>
        <desc>queue_peek(+Q,-T)
    Examines the front of the queue Q.</desc>
</pred>

<pred>
        <id>queue_get(+G,-T)</id>
        <desc>queue_get(+Q,-T)
    Gets the term T from the front of the queue Q.</desc>
</pred>

<pred>
        <id>queue_put(+Q,?T)</id>
        <desc>queue_put(+Q,?T)
    Puts the term T at the end of the queue Q.</desc>
</pred>

<pred>
        <id>queue_delete(+Q)</id>
        <desc>
queue_delete(+Q)
    Deletes the queue Q.</desc>
</pred>

<pred>
        <id>queue_clear(+Q)</id>
        <desc>
queue_clear(+Q)
    Clears the queue Q.</desc>
</pred>

<pred>
        <id>queue_new(-Q)</id>
        <desc>queue_new(-Q)
    Creates a new queue Q.</desc>
</pred>

<pred>
        <id>queue(+Q)</id>
        <desc>queue(+Q)
    Q is a queue.</desc>
</pred>

<pred>
        <id>stream_property(?S,?Prop)</id>
        <desc>stream_property(?S,?Prop) [ISO]
    The stream S has the property Prop. This predicate can be used
    for checking specific properties of specific streams, but can also
    be used to generate, through backtracking, all the open streams
    along with their properties. The supported stream properties are::


      - alias(A) - A is unified with one of the aliases of the stream.
          If A is already bound, a simple check is performed to see if
          A is an alias for the stream.
      - encoding(A) - A is unified with the character encoding
          associated with the stream S.
      - bom(A) - Bool is 'true' or 'false' depending on the stream S
          if a file stream that detects the BOM character when the file
          is opened for reading, or writes a BOM character when the file
          is opened for writing.
      - encoding(A) - A is unified with the character encoding
          associated with the stream S.
      - end_of_stream(A) - If the position of S is before the end-of-stream
          then A is unified with 'not'; if the position of S is exactly
          end-of-stream then A is unified with 'at'; if the position of S is
          past-end-of-stream then A is unified with 'past'.
      - eof_action(A) - A is unified with the eof_action for the stream S.
      - file_name(A) - If the stream S is connected to a file then the atom A
          is the name of the file. This property in only available for
          streams connected to files.
      - file_path(L) - If the stream S is connected to a file then the
          list L is the path of the file. L is a list (cf. section
          "Filesystem"). This property in only available for streams
          connected to files.
      - input - The stream S is an input stream.
      - mode(A) - A is unified with the mode of the stream S. The mode
          was specified when the stream was opened and the possible values
          are 'read',  'write' and 'append'
      - output - The stream S is an output stream.
      - position(T) - T is unified with the current stream position.
          A stream position is an opaque term that is handled using the
          predicate stream_position_data/3.
      - reposition(Bool) -  Bool is 'true' or 'false' depending on the
          stream S allows repositioning.
      - tty(Bool) - Bool is 'true' or 'false' depending on the stream S
          is connected to a terminal.
      - type(A) - A is unified with the atoms 'text' or 'binary' depending
          on the type of the stream S.</desc>
</pred>

<pred>
        <id>put_block(+S,+B)</id>
        <desc>put_block(+S,+B)
    Writes the entire contents of the buffer B to the stream S.</desc>
</pred>

<pred>
        <id>get_block(+S,+B,+N)</id>
        <desc>get_block(+S,+B,+N)
    Reads N bytes from the stream S into the buffer B.
    The previous contents of the buffer is destroyed.
    If the end-of-file is encountered, the actual number
    of transfered bytes can be lower than N. To find out
    the exact number of transfered bytes use the
    goal buffer_size(B,X,X).</desc>
</pred>

<pred>
        <id>get_block(+S,+B)</id>
        <desc>get_block(+S,+B)
    Reads the entire stream S into the buffer B.
    To find out the exact number of transfered bytes
    use the goal buffer_size(B,X,X) (or use
    fs_property(FName,size,X) before reading, if the stream
    is a file stream).</desc>
</pred>

<pred>
        <id>put(+S,+N)</id>
        <desc>put(+S,+N)
    Similar to put_code(S,N), if S is a text stream.
    Similar to put_byte(S,N), if S is a binary stream.</desc>
</pred>

<pred>
        <id>put(+N)</id>
        <desc>
put(+N)
    Similar to put_code(N), if the current input stream is a text stream.
    Similar to put_byte(N), if the current input stream is a binary stream.</desc>
</pred>

<pred>
        <id>peek0(+S,-N)</id>
        <desc>peek0(+S,-N)
    Similar to peek_code(S,N), if S is a text stream.
    Similar to peek_byte(S,N), if S is a binary stream.</desc>
</pred>

<pred>
        <id>peek0(-N)</id>
        <desc>peek0(-N)
    Similar to peek_code(N), if the current input stream is a text stream.
    Similar to peek_byte(N), if the current input stream is a binary stream.</desc>
</pred>

<pred>
        <id>skip(+S,+N)</id>
        <desc>skip(+S,+N)
    If S is a text stream, skips over chars in S until the first occurrence
    of the char with Unicode code N.
    If S is a binary stream, skips over bytes in S until the first occurrence
    of the the byte N.</desc>
</pred>

<pred>
        <id>skip(+N)</id>
        <desc>skip(+N)
    If the current input stream is a text stream, skips over chars
    in the current input stream until the first occurrence of the
    char with Unicode code N.
    If the current input stream is a binary stream, skips over bytes
    in the current input stream until the first occurrence of the
    byte N.</desc>
</pred>

<pred>
        <id>get0(+S,+N)</id>
        <desc>
	get0(+S,-N)
    Similar to get_code(S,N), if S is a text stream.
    Similar to get_byte(S,N), if S is a binary stream.</desc>
</pred>

<pred>
        <id>get0(-N)</id>
        <desc>get0(-N)
    Similar to get_code(N), if the current input stream is a text stream.
    Similar to get_byte(N), if the current input stream is a binary stream.</desc>
</pred>

<pred>
        <id>flush_output_all</id>
        <desc>
	flush_output_all
    Flushes the output of all active streams.</desc>
</pred>

<pred>
        <id>flush_output(+S)</id>
        <desc>
	flush_output(+S) [ISO]
    Flushes the output stream S.</desc>
</pred>

<pred>
        <id>flush_output</id>
        <desc>flush_output [ISO]
    Flushes the current output stream.</desc>
</pred>

<pred>
        <id>at_end_of_stream(+S)</id>
        <desc>at_end_of_stream(+S) [ISO]
    Succeeds if the position of the input stream S is end-of-stream or
    past-end-of-stream. If S is a text stream, the goal at_end_of_stream(S)
    is almost equivalent to the goal peek_char(S,end_of_file). The only
    difference is that no error message will be issued if eof_action(error)
    is set for the S and the position of S is already past-end-of-stream.
    The same applies mutati mutandis to binary streams.</desc>
</pred>

<pred>
        <id>at_end_of_stream</id>
        <desc>at_end_of_stream [ISO]
    Succeeds if the position of the current input stream is end-of-stream
    or past-end-of-stream.</desc>
</pred>

<pred>
        <id>put_byte(+S,+N)</id>
        <desc>put_byte(+S,+N) [ISO]
    Writes the byte N to the output stream S.</desc>
</pred>

<pred>
        <id>put_byte(+N)</id>
        <desc>put_byte(+N) [ISO]
    Writes the byte N to the current output stream.</desc>
</pred>

<pred>
        <id>peek_byte(+S,-N)</id>
        <desc>
	peek_byte(+S,-N) [ISO]
    Similar to get_byte(S,N), but does not consume the returned byte.</desc>
</pred>

<pred>
        <id>peek_byte(-N)</id>
        <desc>
	peek_byte(-N) [ISO]
    Similar to get_byte(N), but does not consume the returned byte.</desc>
</pred>

<pred>
        <id>get_byte(+S,-N)</id>
        <desc>get_byte(+S,-N) [ISO]
    Gets the next byte from the input stream S.
    At end-of-file, -1 is returned.</desc>
</pred>

<pred>
        <id>get_byte(-N)</id>
        <desc>get_byte(-N) [ISO]
    Gets the next byte from the current input stream.
    At end-of-file, -1 is returned.</desc>
</pred>

<pred>
        <id>format(_G1410,_G1411,_G1412)</id>
</pred>

<pred>
        <id>format(_G1405,_G1406)</id>
</pred>

<pred>
        <id>format(_G1401)</id>
</pred>

<pred>
        <id>tab(+S,+N)</id>
        <desc>tab(+S,+N)
    Writes N spaces to the output stream S.</desc>
</pred>

<pred>
        <id>tab(+N)</id>
        <desc>tab(+N)
    Writes N spaces to the current output stream.</desc>
</pred>

<pred>
        <id>nl(+S)</id>
        <desc>nl(+S)
    Writes a newline to the output stream S.</desc>
</pred>

<pred>
        <id>nl</id>
        <desc>nl
    	Writes a newline to the current output stream.</desc>
</pred>

<pred>
        <id>put_code(+S,+N)</id>
        <desc>put_code(+S,+N) [ISO]
    Writes the char with Unicode code N to the output stream S.</desc>
</pred>

<pred>
        <id>put_code(+N)</id>
        <desc>put_code(+N) [ISO]
    Writes the char with Unicode code N to the current output stream.</desc>
</pred>

<pred>
        <id>put_char(+S,+C)</id>
        <desc>
	put_char(+S,+C) [ISO]
    Writes the given char to the output stream S.</desc>
</pred>

<pred>
        <id>put_char(+C)</id>
        <desc>put_char(+C) [ISO]
    Writes the given char to the current output stream.</desc>
</pred>

<pred>
        <id>peek(+S,-N)</id>
        <desc>peek(+S,-N)
    Gets the Unicode code of the next printing char from S,
    but does not consume the returned char.
    End-of-file is denoted by the value associated with the
    'eof_code' Prolog flag.</desc>
</pred>

<pred>
        <id>peek(-N)</id>
        <desc>peek(-N)
    Gets the Unicode code of the next printing char from
    the current input stream, but does not consume the returned char.
    End-of-file is denoted by the value associated with the 'eof_code'
    Prolog flag.</desc>
</pred>

<pred>
        <id>peek_code(+S,-N)</id>
        <desc>peek_code(+S,-N) [ISO]
    Similar to get_code(S,N), but does not consume the
    returned char.</desc>
</pred>

<pred>
        <id>peek_code(-N)</id>
        <desc>peek_code(-N) [ISO]
    Similar to get_code(N), but does not consume the
    returned char.</desc>
</pred>

<pred>
        <id>peek_char(+S,-C)</id>
        <desc>peek_char(+S,-C) [ISO]
    Similar to get_char(S,C), but does not consume the
    returned char.</desc>
</pred>

<pred>
        <id>peek_char(-C)</id>
        <desc>peek_char(-C) [ISO]
    Similar to get_char(C), but does not consume the
    returned char.</desc>
</pred>

<pred>
        <id>get_char_with_prompt(_G1335,_G1336,_G1337)</id>
</pred>

<pred>
        <id>get_single_char(_G1331)</id>
        <desc>get_single_char(-N)
    Gets the Unicode code of the next char from stream 'user_input'.
    Does not wait for the return key, unlike get_code/1. The character
    is not echoed. Useful for games and for keyboard menu selection.
    The name of this predicate is from SWI-Prolog.
    In some installations it might not possible to support this
    behaviour. When such is the case, an entire line is read and
    the code of the first non-space character of the line is returned.</desc>
</pred>

<pred>
        <id>get_line(+S,-A)</id>
        <desc>get_line(+S,-A)
    Reads an entire line as an atom. At end-of-file returns
    the code specified by the 'eof_code' Prolog flag.</desc>
</pred>

<pred>
        <id>get_line(-A)</id>
        <desc>get_line(-A)
    Reads an entire line of text as an atom. At end of
    file return the code specified by the 'eof_code' Prolog flag.</desc>
</pred>

<pred>
        <id>get(+S,-N)</id>
        <desc>get(+S,-N)
    Gets the Unicode code of the next printing char from S.
    End-of-file is denoted by the value associated with the
    'eof_code' Prolog flag.</desc>
</pred>

<pred>
        <id>get(-N)</id>
        <desc>get(-N)
    Gets the Unicode code of the next printing char from
    the current input stream. End-of-file is denoted
    by the value associated with the 'eof_code' Prolog flag.</desc>
</pred>

<pred>
        <id>get_code(+S,-N)</id>
        <desc>get_code(+S,-N) [ISO]
    Gets the Unicode code of the next char from stream S.
    At end-of-file, the code specified by the 'eof_code' Prolog flag
    is returned.</desc>
</pred>

<pred>
        <id>get_code(-N)</id>
        <desc>get_code(-N) [ISO]
    Gets the Unicode code of the next char from the current
    input stream. At end-of-file, the code specified by the
    'eof_code' Prolog flag is returned.</desc>
</pred>

<pred>
        <id>get_char(+S,-C)</id>
        <desc>get_char(+S,-C) [ISO]
    Gets the next char from stream S. At end-of-file,
    the atom 'end_of_file' is returned.</desc>
</pred>

<pred>
        <id>get_char(-C)</id>
        <desc>get_char(-C) [ISO]
    Gets the next char from the current input stream. At end-of-file,
    the atom 'end_of_file' is returned.</desc>
</pred>

<pred>
        <id>told</id>
        <desc>told
    Closes the current output stream and changes it to 'user_output'.</desc>
</pred>

<pred>
        <id>telling(-S)</id>
        <desc>telling(-S)
    Gets the current output stream except that if the current input
    stream is 'user_output' the atom 'user' is returned.</desc>
</pred>

<pred>
        <id>tell(+S)</id>
        <desc>tell(+S)
    If S is an atom, the file named S is opened (if not
    already open) and is made the current output stream. If S
    is a stream term then is made the current output stream.</desc>
</pred>

<pred>
        <id>seen</id>
        <desc>seen
    Closes the current input stream and changes it to 'user_input'.</desc>
</pred>

<pred>
        <id>seeing(-S)</id>
        <desc>seeing(-S)
    Gets the current input stream except that if the current input
    stream is 'user_input' the atom 'user' is returned.</desc>
</pred>

<pred>
        <id>see(+S)</id>
        <desc>see(+S)
    If S is an atom, the file named S is opened (if not
    already open) and is made the current input stream. If S
    is a stream term then is made the current input stream.</desc>
</pred>

<pred>
        <id>current_output(_G1271)</id>
        <desc>current_output(-S) [ISO]
    Gets the current output stream.</desc>
</pred>

<pred>
        <id>set_output(+S)</id>
        <desc>set_output(+S) [ISO]
    Makes stream S the current output stream.
        </desc>
</pred>

<pred>
        <id>current_input(-S)</id>
        <desc>current_input(-S) [ISO]
    Gets the current input stream.</desc>
</pred>

<pred>
        <id>set_input(+S)</id>
        <desc>set_input(+S) [ISO]
    Makes stream S the current input stream.</desc>
</pred>

<pred>
        <id>streams</id>
        <desc>streams
    Shows details about all the currently opened streams.</desc>
</pred>

<pred>
        <id>current_stream(-Name,-Mode,-Path,?Stream)</id>
        <desc>current_stream(-Name,-Mode,-Path,?Stream)
   Similar to current_stream/3, but also provides the value of Path.
   If you do not need the value of Path, use the first version
   because it is much more efficient.</desc>
</pred>

<pred>
        <id>current_stream(-Name,-Mode,?Stream)</id>
        <desc>current_stream(-Name,-Mode,?Stream)
   Provides read-only access to the internal
   stream table. Can also be used to generate, through
   backtracking, all the existing streams, with their name and mode.</desc>
</pred>

<pred>
        <id>close(+S,+O)</id>
        <desc>close(+S, +O) [ISO]
    Closes the stream S, according to the option list . The available
    options are:

        - force(false) - in case of error, an exception is issued and the
          stream is not closed.
        - force(true) - errors are silently ignored and the stream is
          always closed.</desc>
</pred>

<pred>
        <id>close(+S)</id>
        <desc>close(+S) [ISO]
    Equivalent to close(S, [force(false)]).</desc>
</pred>

<pred>
        <id>open_null_stream(-S)</id>
        <desc>open_null_stream(-S)
    Creates a new null stream and returns it in S. A null stream is
    a particular form of output stream that does not have any particular
    encoding associated with it. All output operations are compatible
    with null streams. A null stream will discard all characters, terms
    and bytes written to it.</desc>
</pred>

<pred>
        <id>open_buffer_stream(+B,+M,-S,+O)</id>
        <desc>open_buffer_stream(+B,+M,-S,+O)
    Opens a stream S over the buffer B.
    The mode M is one of the atoms: 'read', 'write', 'append'.
    O is an option list. The available options and their default values
    are the same as in open/4.</desc>
</pred>

<pred>
        <id>open_buffer_stream(+B,+M,-S)</id>
        <desc>open_buffer_stream(+B,+M,-S)
    Opens a stream S over buffer B. The mode M is one
    of the atoms: 'read', 'write', 'append'.
    The character encoding that becomes associated with
    the stream is the default encoding, indicated by the
    Prolog variable 'encoding'.
    Equivalent to open_buffer_stream(B, M, S, []).</desc>
</pred>

<pred>
        <id>open(+F,+M,-S,+O)</id>
        <desc>open(+F,+M,-S,+O) [ISO]
    Opens a stream S over the file specified by atom F.
    The mode M is one of following atoms: 'read', 'write', 'append'.
    O is an option list. The available options are::


        - alias(A) - specifies the atom  A as an alias for the stream.
        - bom(A) - specifies the attitude of the stream towards the
          BOM character (cf. previous section) when a stream is opened.
          The value 'true' enables BOM detection for input text file stream
          and BOM emission for output text file streams. The DEFAULT is 'true'
          for input text file streams and 'false' otherwise (all output
          streams and all non-text streams.)
        - encoding(A) - specifies the character encoding used in the stream,
          as explained in a previous section.
          DEFAULT='text' (represents the value of the Prolog flag 'encoding')
        - eof_action(A) - specifies the effect of attempting to read beyond
          the end-of-stream position. The possible values for A are: 'error'
          (raises an exception), 'eof_code' (keeps returning 'end_of_file'),
          and 'reset' (used for tty files only).
          DEFAULT = 'eof_code'.
        - reposition(A) - specifies whether it is possible to reposition the
          stream. The possible values for A are 'false' and 'true'.
          DEFAULT = 'true'.
        - type(A) - specifies whether the stream is a text stream or a
          binary stream. The possible values for A are 'text' and 'binary'.
          DEFAULT = 'text'.</desc>
</pred>

<pred>
        <id>open(+F,+M,-S)</id>
        <desc>open(+F,+M,-S) [ISO]
    Equivalent to open(F, M, S, []).</desc>
</pred>

<pred>
        <id>stream(+S)</id>
        <desc>stream(+S)
    S is a valid active stream.</desc>
</pred>

<pred>
        <id>zex</id>
</pred>

<pred>
        <id>zpl</id>
</pred>

<pred>
        <id>absolute_file_name(+RelativePatg,-AbsolutePath)</id>
        <desc>absolute_file_name(+RelativePath,-AbsolutePath)
    Expand the local filename RelativePath into the canonized absolute
    path AbsolutePath. RelativePath and AbsolutePath are both atoms.
    This predicate is used by consult/1 to uniquely identify files.
    This is only a syntactic transformation. The file does not need to exist.</desc>
</pred>

<pred>
        <id>fs_files(-L)</id>
        <desc>fs_files(-L)
    Gets all files/dirs inside the current directory.</desc>
</pred>

<pred>
        <id>fs_home</id>
        <desc>fs_home
    Resets the current directory.</desc>
</pred>

<pred>
        <id>fs_cwd(-Ao,+An)</id>
        <desc>fs_cwd(-Ao,+An)
    Changes the current directory from Ao to An. This predicate is similar
    to fs_cd/2 except that the directories are represented using atoms
    and not lists. Additionally, the An parameter can also be a path
    relative to the current directory, therefore not necessarily an
    absolute path.</desc>
</pred>

<pred>
        <id>fs_cwd(-A)</id>
        <desc>fs_cwd(-A)
    Obtains the current directory. This predicate is similar to fs_cd/1
    except that the returned value is an atom and not a list.</desc>
</pred>

<pred>
        <id>fs_cd(-Lo,+Ln)</id>
        <desc>fs_cd(-Lo,+Ln)
    Changes the current directory from Lo to Ln. Lo is unified with an
    absolute path in the filesystem, represented as a reversed list of
    filenames. The supplied Ln must also have the same form.
    The goal fs_cd(X,X) gets the current directory.</desc>
</pred>

<pred>
        <id>fs_cd(-L)</id>
        <desc>fs_cd(-L)
    Obtains the current directory. L is unified with an absolute
    path in the filesystem, represented as a reversed list of filenames.</desc>
</pred>

<pred>
        <id>fs_mkdir(+F)</id>
        <desc>fs_mkdir(+F)
    Creates a new directory named F.</desc>
</pred>

<pred>
        <id>fs_property(+F,+A,-R)</id>
        <desc>fs_property(+F,+A,-R)
    R is the value of the property A of existing
    file/dir F. As yet, the supported properties are:

    ========      =============================
    Property      Possible results
    ========      =============================
    type          atoms 'file', 'dir', 'other'
    size          the size of the file in bytes
    readable      atoms 'false', 'true'
    writable      atoms 'false', 'true'
    time          list [access_time, modification_time]
    ========      =============================

    The two numbers of the property 'time' (access_time and
    modification_time) represent times measured in seconds since
    00:00:00 UTC, January 1, 1970. This applies to every OS even
    Windows. The values are always exact to the second, despite
    they may show up as float numbers.</desc>
</pred>

<pred>
        <id>delete_file(+F)</id>
        <desc>delete_file(+F)
    Quintus-Prolog compatibly predicate.
    Identical to fs_delete/2.</desc>
</pred>

<pred>
        <id>fs_delete(+F)</id>
        <desc>fs_delete(+F)
    Deletes existing file/dir F. Only empty directories
    can be deleted.</desc>
</pred>

<pred>
        <id>rename_file(+Fo,+Fn)</id>
        <desc>rename_file(+Fo,+Fn)
    Quintus-Prolog compatible predicate.
    Identical to fs_rename/2.</desc>
</pred>

<pred>
        <id>rename(+Fo,+Fn)</id>
        <desc>rename(+Fo,+Fn)
    C-Prolog compatibly predicate. Identical to fs_rename/2.</desc>
</pred>

<pred>
        <id>fs_rename(+Fo,+Fn)</id>
        <desc>fs_rename(+Fo,+Fn)
    Renames existing file/dir Fo as Fn. If Fn is the
    empty list \[] then Fo is deleted.</desc>
</pred>

<pred>
        <id>fs_exists_dir(+F)</id>
        <desc>fs_exists_dir(+F)
    Checks if there is a directory named F.</desc>
</pred>

<pred>
        <id>fs_exists_file(+F)</id>
        <desc>fs_exists_file(+F)
    Checks if there is a file named F.</desc>
</pred>

<pred>
        <id>exists(+F)</id>
        <desc>exists(+F)
    C-Prolog compatibly predicate. Identical to fs_exists/1.</desc>
</pred>

<pred>
        <id>file_exists(+F)</id>
        <desc>file_exists(+F)
    Quintus-Prolog compatibility predicate.
    Identical to fs_exists/1.</desc>
</pred>

<pred>
        <id>fs_exists(+F)</id>
        <desc>fs_exists(+F)
    Checks if there is a file/dir named F.</desc>
</pred>

<pred>
        <id>current_char_conversion(?CN1,?CN2")</id>
        <desc>current_char_conversion(?CN1,?CN2) [ISO]
    Consults the current char_conversion table, which in CxProlog
    is a fixed dummy table that maps each character onto itself.</desc>
</pred>

<pred>
        <id>char_conversion(+CN1,+CN2)</id>
        <desc>char_conversion(+CN1,+CN2) [ISO]
    In CxProlog, this is a compatibility predicate that does nothing.
    In CxProlog, the current char_conversion table always define
    the fixed identity transformation.</desc>
</pred>

<pred>
        <id>char_ispunct(+CN)</id>
        <desc>char_ispunct(+CN)
    CN is printable but not a space or an alphanumeric character.</desc>
</pred>

<pred>
        <id>char_isprint(+CN)</id>
        <desc>char_isprint(+CN)
    CN is a printable char or Unicode code, including spaces.</desc>
</pred>

<pred>
        <id>char_issymbol(_G1093)</id>
        <desc>char_issymbol(+CN)
    The ascii symbols are exactly '#$&amp;*+-./:;&lt;=>?@\^`~' but
    there are many more symbols in the latin-1 subrange.
    Furthermore, in the current version of CxProlog all the chars
    outside the latin-1 range are seen as symbols.</desc>
</pred>

<pred>
        <id>char_isspace(+CN)</id>
        <desc>char_isspace(+CN)
    CN is one of these ' \b\f\n\r\t\v'.</desc>
</pred>

<pred>
        <id>char_isdigit(+CN)</id>
        <desc>char_isdigit(+CN)
    CN is one of these '0123456789'.</desc>
</pred>

<pred>
        <id>char_isupper(+CN)</id>
        <desc>char_isupper(+CN)
    CN upper case alphabetic .</desc>
</pred>

<pred>
        <id>char_islower(+CN)</id>
        <desc>char_islower(+CN)
    CN lower case alphabetic.</desc>
</pred>

<pred>
        <id>char_isalpha(+CN)</id>
        <desc>char_isalpha(+CN)
    CN is alphabetic.</desc>
</pred>

<pred>
        <id>char_isalnum(+CN)</id>
        <desc>char_isalnum(+CN)
    CN is alphanumeric. CN stands for a character or a Unicode code.</desc>
</pred>

<pred>
        <id>char_reorder(+CN1,+CN2)</id>
        <desc>char_reorder(+CN1, +CN2)
    The comparison code of character CN1 is set to CN2 (CN1 and CN2 stand for
    characters or Unicode codes.) The comparison between two chars
    is first based on their comparison codes and next on their Unicode codes.
    As an example, the easier way to insert the seven variants of the low
    case 'a' between the letters 'a' and 'b' is simply set to 'a' the
    comparison codes of the seven variants:
    *char_reorder(224,'a'), char_reorder(225,'a'), char_reorder(226,'a'),
    char_reorder(227,'a'), char_reorder(228,'a'), char_reorder(229,'a'),
    char_reorder(230,'a').*</desc>
</pred>

<pred>
        <id>char_reorder(+A)</id>
        <desc>char_reorder(+A)
    The atom A designates either a locale or a predefined character ordering.
    Only abbreviated locales are accepted, as in the examples: 'pt_PT',
    'pt_BR' or 'en_EN'. There are only two predefined character orderings:

        'none' - The character ordering is based on the numeric character
                 codes, meaning no reordering is active. DEFAULT.
        'latin1_ignore_diacriticals' - The comparison code of any
                 character carrying a diacritical is the code of the
                 corresponding character that does not carry the diacritical.</desc>
</pred>

<pred>
        <id>char_reorder</id>
        <desc>char_reorder
    Shows the internal character reorder table.</desc>
</pred>

<pred>
        <id>char_code(?C,?N)</id>
        <desc>char_code(?C,?N)
    The character (one-char atom) C has Unicode code N.</desc>
</pred>

<pred>
        <id>ivars</id>
        <desc>ivars
    Shows all the existing ivars and corresponding values.</desc>
</pred>

<pred>
        <id>current_ivar(-A,-T)</id>
        <desc>current_ivar(-A,-T)
    Generates, through backtracking, all the existing
    ivars and the corresponding values.</desc>
</pred>

<pred>
        <id>=:</id>
        <desc>+A =: -T
    Gets the current value of ivar A. Fails if A is undefined.</desc>
</pred>

<pred>
        <id>:=</id>
        <desc>+A := ?T
    Normal assignment. Sets ivar A to term T. Always succeeds.
    In this and following predicates, the term T can be cyclic.</desc>
</pred>

<pred>
        <id>_G1031#:=_G1032</id>
</pred>

<pred>
        <id>&amp;:=</id>
        <desc>+A &amp;:= ?T
    Backtrackable assignment. Sets ivar A to T, but
    automatically restores the previous state and value
    of A on backtracking. Always succeeds.</desc>
</pred>

<pred>
        <id>?:=</id>
        <desc>+A ?:= ?T
    Creation assignment. Initializes ivar A with T
    only if A does not exist already. Nothing is done if A
    already exists. Always succeeds.</desc>
</pred>

<pred>
        <id>ivar_delete(_G1017)</id>
        <desc>ivar_delete(+A)
    Deletes the ivar A. Always succeeds.</desc>
</pred>

<pred>
        <id>ivar(+A)</id>
        <desc>ivar(+A)
    A is a currently defined ivar.</desc>
</pred>

<pred>
        <id>aliases</id>
        <desc>aliases
    Shows all the existing aliases and corresponding values.</desc>
</pred>

<pred>
        <id>unalias(+A,+T)</id>
        <desc>unalias(+A, +T)
    Removes an existing binding from alias A to the extra-value T.</desc>
</pred>

<pred>
        <id>alias(+A,+T)</id>
        <desc>alias(+A, +T)
    Bind the alias A with the extra-value T.</desc>
</pred>

<pred>
        <id>write_depth(+N1,+N2)</id>
        <desc>write_depth(+N1,+N2)
    Sets the maximum term depth and the maximum list
    length used by predicates write/1, write/2, etc.
    0 (zero) means no limit. The initial values are
    respectively 30 and 999.</desc>
</pred>

<pred>
        <id>quote(+A1,-A2)</id>
        <desc>quote(+A1,-A2)
    Quotes a piece of text.</desc>
</pred>

<pred>
        <id>atom_termq(?A,?T)</id>
        <desc>atom_termq(?A,?T)
    Variant of *atom_term(A,T)* which quotes atoms where
    necessary so that the conversion is reversible.</desc>
</pred>

<pred>
        <id>atom_term(?A,?T)</id>
        <desc>atom_term(?A,?T)
    Converts between a term T and its textual representation A.</desc>
</pred>

<pred>
        <id>write_canonical(+S,+T)</id>
        <desc>write_canonical(+S,+T) [ISO]
    Like write_canonical/1 except that the output is sent to the stream S.</desc>
</pred>

<pred>
        <id>write_canonical(+T)</id>
        <desc>write_canonical(+T) [ISO]
    Variant of write(T) that quotes atoms and ignores operators, so that
    read/1 can read the term back even if the operator definitions changes.
    Defined as::


    write_canonical(T) :-
         current_output(S),
         write_term(S, T, [quoted(true), ignore_ops(true), numbervars(false)].</desc>
</pred>

<pred>
        <id>displayln(+S,+T)</id>
        <desc>displayln(+S, +T)
    Variant of display(S,T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>displayln(+T)</id>
        <desc>displayln(+T)
    Variant of display(T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>display(+S,+T)</id>
        <desc>display(+S,+T)
    Like display/1 except that the output is sent to the stream S.</desc>
</pred>

<pred>
        <id>display(+T)</id>
        <desc>display(+T)
    Writes term to stream user_output, ignoring operators. Defined as::

    display(T) :-
         current_output(S),
         write_term(S, T, [ignore_ops(true), numbervars(false)].
        </desc>
</pred>

<pred>
        <id>print(+S,+T)</id>
        <desc>print(+S,+T)
    Like print/1 except that the output is sent to the stream S.</desc>
</pred>

<pred>
        <id>print(+T)</id>
        <desc>print(+T)
    Writes the term T to the current output stream allowing the user
    to specify how the term is printed. Defined as::


    print(T) :-
         current_output(S),
         write_term(S, T, [portray(true), numbervars(false)]).
        </desc>
</pred>

<pred>
        <id>writeqln(+S,+T)</id>
        <desc>writeqln(+S,+T)
    Variant of writeq(S,T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>writeqln(+T)</id>
        <desc>writeqln(+T)
    Variant of writeq(T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>writeq(+S,+T)</id>
<desc>writeq(+S,+T) [ISO]
    Like writeq/1 except that the output is sent to the stream S.</desc>
</pred>

<pred>
        <id>writeq(+T)</id>
        <desc>writeq(+T) [ISO]
    Writes the term T to the current output stream quoting atoms where
    necessary so that read/1 could read the term back  (assuming that the
    operator definitions did not changed). Defined as::


    writeq(T) :-
         current_output(S),
         write_term(S, T, [quoted(true), numbervars(true)]).</desc>
</pred>

<pred>
        <id>writeln(+S,+T)</id>
        <desc>writeln(+S,+T)
    Variant of write(S,T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>writeln(+T)</id>
        <desc>writeln(+T)
    Variant of write(T) that outputs an extra newline char.</desc>
</pred>

<pred>
        <id>write(+S,+T)</id>
        <desc>write(+S,+T) [ISO]
    Like write/1 except that the output is sent to the stream S.</desc>
</pred>

<pred>
        <id>write(+T)</id>
        <desc>write(+T) [ISO]
    Writes the term T to the current output stream. Defined as::


     write(T) :-
         current_output(S),
         write_term(S, T, [numbervars(true)]).</desc>
</pred>

<pred>
        <id>write_term(+S,+T,+Loptions)</id>
        <desc>write_term(+S, +T, +Loptions) [ISO]
    Writes the term T to the output stream S according to the current
    operator table and the provided write-options, which are the same of
    write_term/2.</desc>
</pred>

<pred>
        <id>write_term(+T,+Loptions)</id>
        <desc>write_term(+T, +Loptions) [ISO]
    Writes the term T to the current output stream using to the current
    operator table and the provided write-options.
    Example: write_term(T, [quoted(true), numbervars(true)]).
    The write-options are the following::

    character_escapes(+Boolean) - This option is used for overriding
      the global flag 'character_escapes', during the writing of a
      particular term.
      DEFAULT=Taken from the global flag 'character_escapes'.

    ignore_ops(Boolean) [ISO] - If true then the operator table is ignored
      and the term is written in functional notation.
      DEFAULT=ignore_ops(false).

    numbervars(Boolean) [ISO] - If true then every subterm of the form
      '$VAR(N)', where N is an integer, is written as a variable
      name consisting of a capital letter possible followed by a number.
      This is appropriate to print the results of numbervars/3.
      DEFAULT=numbervars(true).

    portray(Boolean) - If true then the hook predicate portray/1 gains the
      responsibility of printing any subterm that is not a variable.
      If portray/1 succeeds the subterm is assumed already printed.
      If portray/1 fails and the term is atomic, write_term writes the
      term directly. If portray/1 fails and the term is compound,
      write_term writes the principal functor of the term and them calls
      itself recursively on the arguments of the term.
      DEFAULT=portray(false).

    quoted(Boolean) [ISO] - If true each atom and functor is quoted where
      necessary so that read/1 could read the term back.
      DEFAULT=Taken from the global flag 'force_quoted'.</desc>
</pred>

<pred>
        <id>portray(Boolean)</id>
        <desc>portray(Boolean) - If true then the hook predicate portray/1 gains the
      responsibility of printing any subterm that is not a variable.
      If portray/1 succeeds the subterm is assumed already printed.
      If portray/1 fails and the term is atomic, write_term writes the
      term directly. If portray/1 fails and the term is compound,
      write_term writes the principal functor of the term and them calls
      itself recursively on the arguments of the term.
      DEFAULT=portray(false).</desc>
</pred>

<pred>
        <id>read_tokens(+S,-L)</id>
        <desc>read_tokens(+S,-L)
    Reads from S an entire line of text as a list of
    tokens [token = atomic lexical element]. If the
    line is empty then the empty list is returned. At
    end-of-file, the atom 'end_of_file' is returned.</desc>
</pred>

<pred>
        <id>read_tokens(-L)</id>
        <desc>read_tokens(-L)
    Reads an entire line of text as a list of tokens
    (token = atomic lexical element). If the line is
    empty then the empty list is returned. At
    end-of-file, the atom 'end_of_file' is returned.</desc>
</pred>

<pred>
        <id>varnames(-L)</id>
        <desc>varnames(-L)
    L is a list of pairs Var=Name, telling the names of
    all the variables in the last term returned by
    read/1, read/2 or atom_term/2.</desc>
</pred>

<pred>
        <id>read_with_source(+S,-T,-A)</id>
        <desc>read_with_source(+S,-T,-A)
    Similar to read/2, except that it returns in the atom A
    the exact source text that gave rise to the term.</desc>
</pred>

<pred>
        <id>read(+S,-T)</id>
        <desc>read(+S,-T) [ISO]
    Like read/1 except that the input is obtained from stream S.</desc>
</pred>

<pred>
        <id>read(_G866)</id>
        <desc>read(-T) [ISO]
    Reads the term T from the current output stream. The names of the
    variables in the term T can be obtained using varnames/1.
    Defined as::


     read(T) :-
         current_input(S),
         read_term(S, T, []).</desc>
</pred>

<pred>
        <id>read_term(+S,-T,+Loptions)</id>
        <desc>read_term(+S, -T, +Loptions) [ISO]
    Like read_term/2 except that the input is obtained from stream S.</desc>
</pred>

<pred>
        <id>read_term(-T,+Loptions)</id>
        <desc>read_term(-T, +Loptions) [ISO]
    Reads the term T from the current input stream using to the current
    operator table and the provided read-options. At end-of-file, the atom
    'end_of_file' is returned.
    Example: read_term(T, [character_escapes(false), variables(V)]).
    The read-options are the following::

    character_escapes(+Boolean) - This option is used for temporary
      overriding the global flag 'character_escapes', during the reading
      of a particular term.

    double_quotes(+Option) - This option is used for temporary
      overriding the global flag 'double_quotes', during the reading
      particular term. The possible values for this option are
      of a 'chars', 'codes', 'atom', 'struct'.

    singletons(-L) [ISO] - L is a list of pairs Var=Name, telling the
      names of all the variables that occur only once in the term T.

    variables(-L) [ISO] - L is a list of all the variables that occur
      in the term T, in left-to-right order.

    variable_names(-L) [ISO] - L is a list of pairs Var=Name, telling the
      names of all the variables that occur in the term T.
        </desc>
</pred>

<pred>
        <id>threads</id>
        <desc>threads
    Shows all existing threads.</desc>
</pred>

<pred>
        <id>current_thread(?Z)</id>
        <desc>current_thread(?Z)
    Generates, through backtracking, all the existing threads.</desc>
</pred>

<pred>
        <id>statistics(_G844,_G845)</id>
</pred>

<pred>
        <id>statistics</id>
        <desc>statistics
    Shows the space currently used in the various data
    areas of CxProlog and also the running time since
    startup.</desc>
</pred>

<pred>
	<id>active_thread(-Z)</id>
	<desc>active_thread(-Z)
    Z is the active thread.</desc>
</pred>

<pred>
        <id>thread_kill(+Z)</id>
        <desc>thread_kill(+Z)
    Kills the thread Z.</desc>
</pred>

<pred>
        <id>thread_transfer(+Z,-A)</id>
        <desc>thread_transfer(+Z,-A)
    Transfers control to the thread Z. Possible results
    are: 'going', 'completed', 'failed', 'killed', 'error'.</desc>
</pred>

<pred>
        <id>thread_new(-Z,+Goal,+RestartGoal)</id>
        <desc>thread_new(-Z, +Goal, +RestartGoal)
    Creates a new thread Z. Goal is the startup goal.
    RestartGoal is the goal that is activated
    in case of error or explicit abort/0 call.</desc>
</pred>

<pred>
        <id>thread(+Z)</id>
        <desc>thread(+Z)
    Z is a thread.</desc>
</pred>

<pred>
        <id>current_predicate(?Name,?head)</id>
        <desc>
current_predicate(?Name,?Head)
    The main functor of term Head identifies an user-defined predicate
    from the current unit; the atom Name is the name of that predicate.
    Can be used for simple checks or to generate, through backtracking,
    all the user-defined predicates available in the current unit.
    It is almost equivalent to predicate_property(Head,user_defined);
    the difference is the extra argument Name which makes
    current_predicate/2 faster or more convenient to use, in
    some circumstances.</desc>
</pred>

<pred>
        <id>current_predicate(?P)</id>
        <desc>current_predicate(?P) [ISO]
    P is a predicate indicator for one of the user-defined predicates
    in the current unit. Can be used for simple checks and can also
    be used to generate, through backtracking, all the user-defined
    predicates available in the current unit. The exact same predicates
    could be generated using predicate_property(Head,user_defined),
    albeit the format of the returned predicates is different here.</desc>
</pred>

<pred>
        <id>predicate_property(?Head,?Prop)</id>
        <desc>predicate_property(?Head,?Prop)
    The main functor of term Head identifies a predicate with the property
    Prop available in the current unit. predicate_property/2 can be used
    for simple checks or to generate, through backtracking, all the
    predicates available in the current unit along with their properties.
    The supported predicate properties are:

      - built_in - Built-in predicate. The built-in predicates are
          predefined and available in all the units. They are also
          untraceable by the debugger. A built-in predicate is either
          'static' (immutable) or 'dynamic' (mutable). Dynamic built-ins
          are rare: portray/1 is one example of such predicate.
      - user_defined - Opposite of 'built-in'. The user-defined
          predicates are the local predicates plus the import links.
      - local - Predicate introduced in the current unit using some
          clauses or via a declaration of visible or dynamic.
      - static - Static predicate.
      - dynamic - Dynamic predicate that follows the "logical update
          semantic view".
      - dynamic_iu - Dynamic predicate that follows the "immediate
          update semantic view".
      - imported_from(U) - Import link pointing to a predicate exported
          by the unit designated by U.
      - visible - Exported user-defined predicate. The candidates for
          exporting are the local predicates and the import links.
      - private - Non-exported user-defined predicate.
      - multifile - Predicate is multifile.
      - discontiguous - Predicate is discontiguous.
      - source - Predicate has the source term available.
      - file(F) - F is the absolute file name of the source file
          where the predicate was declared or defined for the first time.
      - full_name(T) - T is unified with a term which fully identifies
          the predicate. Contains a unit name (if the predicate is not
          built-in) and a predicate indicator. Here are some examples:
          'main:a/3', 'books(platao):contains(cat), 'nl/2'. This property
          is available to all predicates, even undefined predicates.
      - number_of_clauses(N) - N is unified with the number of clauses
          of a predicate. This property is only available to local
          predicates and to dynamic built-in predicates.
      - undefined - local static private predicate with no clauses.
          Such a predicate can exist in the database if it invoked from
          the body of some existing clause or if it has been invoked in
          the past. An undefined predicate has no more properties
          besides 'undefined' and 'full_name(T)'. retractall/1 does not
          delete undefined predicates but abolish/1 does that.

    The properties 'static', 'dynamic', 'dynamic_iu' and
    'imported_from(U)' define a partition over the user-defined
    predicates of each unit. The properties 'visible' and 'public'
    also define a partition over the user-defined predicates of
    each unit.

    predicate_property/2 treats the built-in predicates and
    undefined predicates very discreetly. When invoked with the first
    argument uninstantiated, predicate_property/2 does not generate
    built-in and undefined predicates, unless it is forced by the
    following specific requests: predicate_property(X,built_in) and
    predicate_property(X,undefined).</desc>
</pred>

<pred>
        <id>undefs</id>
</pred>

<pred>
        <id>cbuiltins</id>
</pred>

<pred>
        <id>builtins</id>
        <desc>builtins
    Shows all existing built-in predicates.</desc>
</pred>

<pred>
        <id>index(_G794,_G795)</id>
</pred>

<pred>
        <id>discontiguous +FPredSpec</id>
        <desc>:- discontiguous +FPredSpec [ISO]
    This directive declare the predicates specified by FPredSpec
    to be discontiguous. A discontiguous predicate is one that may be
    defined using clauses that are not consecutive in the source file.
    Example: *:-discontiguous a/2, b/4, c/4.*</desc>
</pred>

<pred>
        <id>multifile +FPredSpec</id>
        <desc>:- multifile +FPredSpec [ISO]
    This directive declare the predicates specified by FPredSpec
    to be multifile. A multifile predicate is one that may be defined
    across files. Example: *:-multifile a/2, b/4, c/4.*</desc>
</pred>

<pred>
        <id>dynamic_iu +FPredSpec</id>
        <desc>:- dynamic_iu +FPredSpec
    This directive declares the predicates specified by FPredSpec
    to be dynamic with immediate update semantics.
    It will be always possible to change the declared predicates
    during execution by adding or removing clauses and the semantics
    of the updates will follow the "immediate update semantic view",
    meaning that any change to the database becomes instantly visible to
    all active predicate invocations. There is an large efficiency
    penalty (up to 50%) associated with this semantics because it forces
    determinacy detection to be completely dropped: even a predicate with a
    single clause requires a choice point to run because that execution of
    the clause itself may append new clauses. The "immediate update
    semantic view" is sometimes useful for fulfilling the special
    requirements of some special predicate.
    FPredSpec can be a predicate indicator (Name/Arity), a
    comma-separated sequence of predicate indicators or a list of
    predicate indicators. Example: *:-dynamic_iu a/2, b/4, c/4.*</desc>
</pred>

<pred>
        <id>dynamic +FPredSpec</id>
        <desc>:- dynamic +FPredSpec [ISO]
    This directive declares the predicates specified by FPredSpec
    to be dynamic with logical update semantic. It will be always possible
    to change the declared predicates during execution by adding or
    removing clauses and the semantics of the updates
    will follow the "logical update semantic view",
    meaning that it will be exactly the clauses available at the time
    of each invocation that will considered for that invocation.
    The implementation uses timestamps to achieve this efficiently,
    a technique borrowed from the concurrent database systems.
    The efficiency penalty is usually around 15%, comparing to
    static predicates.
    FPredSpec can be a predicate indicator (Name/Arity), a
    comma-separated sequence of predicate indicators or a list of
    predicate indicators. Example: *:-dynamic a/2, b/4, c/4.*</desc>
</pred>

<pred>
        <id>hide_non_core_builtins</id>
        <desc>hide_non_core_builtins
    Applies hide_builtin/0 to all the non-core built-in predicates (around
    400 predicates). To hide a core built-in predicate, you must call
    hide_builtin/1 explicitly. The core built-in predicates are the
    following::

    true/0, fail/0, false/0, repeat/0, halt/0, exit/0, abort/0, restart/0,
    is/2, raise_exception/1, throw/1, on_exception/3, catch/4, catch/3,
    call/*, apply/2, !/0, not/1, \+/1, ->/2, ;/2, ,/2, try/1, once/1,
    possible/1, gen/1, &lt;&gt;/2, >>/2, >/1, &lt;/1, call_in_empty_context/1,
    with_ivar/3 ;

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    programmer who wants to create an "ALTERNATIVE BOOT FILE".</desc>
</pred>

<pred>
        <id>abolish_builtin(+A,+N)</id>
        <desc>abolish_builtin(+A,+N) [deprecated]
    Same as hide_builtin/2. Exists for backward compatibility. In old
    versions of CxProlog it truly deleted built-in predicates, but this
    was a grave mistake because the implementation of a built-in
    predicate might depend on other built-in predicate.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    programmer who wants to create an "ALTERNATIVE BOOT FILE".</desc>
</pred>

<pred>
        <id>hide_builtin(+A,+N)</id>
        <desc>hide_builtin(+A,+N)
    Simply renames the predefined built-in predicate A/N in a standard way,
    by adding the prefix "builtin_" to its name.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    programmer who wants to create an "ALTERNATIVE BOOT FILE".</desc>
</pred>

<pred>
        <id>rename_builtin(+A,+N,+Anew)</id>
        <desc>rename_builtin(+A,+N,+Anew)
    Renames a predefined built-in predicate from A/N to Anew/N.
    The original predicate descriptor is reused to guarantee
    that all the statically bound invocations of the renamed predicate,
    in the bodies of the existing predicates, continue to be bound
    to the same predicate.

    **Only works at boot time.**
    This predicate is offered as a tool for the sophisticated
    programmer who wants to create an "ALTERNATIVE BOOT FILE".</desc>
</pred>

<pred>
        <id>abolish(+A,+N)</id>
        <desc>abolish(+A,+N)
    Same as abolish(A/N).
        </desc>
</pred>

<pred>
        <id>abolish(_G751)</id>
        <desc>
abolish(+A/+N) [ISO]
    Deletes the predicate A/N from the current unit. Only static
    built-in predicates cannot be abolished. All the other kinds of
    predicate can be abolished: even user-defined static predicates
    and dynamic built-in predicates can be abolished. An abolished
    predicate cannot be found anymore by predicate_property/2,
    current_predicate/1 and current_predicate/2. If an imported
    predicate is abolished, only the import link is deleted and
    the original predicate remains undisturbed in its original unit.
    Dynamic built-in predicates are treated in a special way: the
    clauses are deleted but each predicate stays alive, even if as an
    empty predicate.</desc>
</pred>

<pred>
        <id>assert(+T)</id>
        <desc>assert(+T)
    Same as assertz(T). Non-ISO.</desc>
</pred>

<pred>
        <id>assertz(+T)</id>
        <desc>assertz(+T) [ISO]
    Asserts term T as the last clause of a dynamic predicate,
    in the current unit. If the predicate does not exist it is
    implicitly declared dynamic.</desc>
</pred>

<pred>
        <id>asserta(+T)</id>
        <desc>asserta(+T) [ISO]
    Asserts term T as the first clause of a dynamic predicate,
    in the current unit. If the predicate does not exist it is
    implicitly declared dynamic.</desc>
</pred>

<pred>
        <id>retract(+T)</id>
        <desc>retract(+T) [ISO]
    Erases from the current unit the first clause that matches T.
    The clause must belong to a dynamic predicate. A unit clause
    such as 'f(5)' can be retracted in several ways: retract(f(5)),
    retract((f(5):-true)), retract((f(5):-X)).</desc>
</pred>

<pred>
        <id>clause(+T1,-T2)</id>
        <desc>clause(+T1,-T2) [ISO]
    Searches the current unit for a clause whose head matches T1.
    If found, such clause is unified with the term (T1 :- T2).
    The body of a unit clause is the atom true.</desc>
</pred>

<pred>
        <id>repeat(+N1,-N2)</id>
        <desc>repeat(+N1,-N2)
    Like repeat(N1) and the succession 1, 2, 3, ..., N1
    is generated via N2 on backtracking.</desc>
</pred>

<pred>
        <id>repeat(+N)</id>
        <desc>repeat(+N)
    Succeeds repeatedly on backtracking exactly N times.
    After that fails.</desc>
</pred>

<pred>
        <id>keysort(+L1,-L2)</id>
        <desc>keysort(+L1,-L2)
    Quicksorts list L1 into L2. Items of L1 must have
    the form Key-Value. Sorting is stable with respect to
    the order of the Values</desc>
</pred>

<pred>
        <id>msort(+L1,-L2)</id>
        <desc>msort(+L1,-L2)
    Quicksorts list L1 into L2.</desc>
</pred>

<pred>
        <id>sort(+L1,-L2)</id>
        <desc>sort(+L1,-L2)
    Quicksorts list L1 into L2. Duplicates are removed.</desc>
</pred>

<pred>
        <id>compare(?Order,+T1,+T2)</id>
        <desc>compare(?Order,+T1,+T2)
    Order is one of the atoms '&lt;', '=', '>', indicating how
    T1 and T2 are related in the standard order.</desc>
</pred>

<pred>
        <id>@>=</id>
        <desc>+T1 @>= +T2 [ISO]
    T1 is not before T2 in the standard order.</desc>
</pred>

<pred>
        <id>_@=&lt;</id>
        <desc>+T1 @=&lt; +T2 [ISO]
    T1 is not after T2 in the standard order.</desc>
</pred>

<pred>
        <id>@></id>
        <desc>+T1 @> +T2 [ISO]
    T1 is before T2 in the standard order.</desc>
</pred>

<pred>
        <id>_G680@&lt;_G681</id>
        <desc>+T1 @&lt; +T2 [ISO]
    T1 is before T2 in the standard order.</desc>
</pred>

<pred>
        <id>\\==</id>
        <desc>+T1 \\== +T2 [ISO]
    T1 and T2 are not literally identical.</desc>
</pred>

<pred>
        <id>==</id>
        <desc>+T1 == +T2 [ISO]
    T1 and T2 are literally identical.</desc>
</pred>

<pred>
        <id>unify_with_occurs_check(+T1,+T2)</id>
        <desc>unify_with_occurs_check(+T1,+T2) [ISO]
    Unifies T1 with T2 with the proviso that both terms must unify to
    an acyclic (finite) term. This predicate works as described, no
    matter what is the current state of the 'occurs-check' Prolog flag.</desc>
</pred>

<pred>
        <id>\\=</id>
        <desc>?T1 \\= ?T2 [ISO]
    T1 is not unifiable with T2. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>=</id>
        <desc>?T1 = ?T2 [ISO]
    Unifies T1 with T2. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>between(+N1,+N2,?N3)</id>
        <desc>between(+N1,+N2,?N3)
    If N3 is an integer, checks the condition N1 &lt;= N3 &lt;= N2.
    If N3 is a variable, generates, via backtracking, the succession of
    integers between N1 and N2. The upper limit can be ignored by
    using N2=inf.</desc>
</pred>

<pred>
        <id>plus(?N1,?N2,?N3)</id>
        <desc>plus(?N1,?N2,?N3)
    Defines the relation N3 = N1 + N2. At most, one of the arguments can be
    a variable.</desc>	
</pred>

<pred>
        <id>succ(?N1,?N2)</id>
        <desc>succ(?N1,?N2)
    The non-negative integer N2 is the successor of the
    non-negative integer N1.</desc>
</pred>

<pred>
        <id>>=</id>
        <desc>+E1 >= +E2 [ISO]
    The value of E1 is not less than the value of E2.</desc>
</pred>

<pred>
        <id>=&lt;</id>
        <desc>+E1 =&lt; +E2 [ISO]
    The value of E1 is not greater than the value of E2.</desc>
</pred>

<pred>
        <id>></id>
        <desc>+E1 > +E2 [ISO]
    The value of E1 is greater than the value of E2.</desc>
</pred>

<pred>
        <id>_G618&lt;_G619</id>
        <desc>+E1 &lt; +E2 [ISO]
    The value of E1 is lesser than the value of E2.</desc>
</pred>

<pred>
        <id>=\\=</id>
        <desc>+E1 =\\= +E2 [ISO]
    E1 and E2 do not evaluate to the same number.</desc>
</pred>

<pred>
        <id>=:=</id>
        <desc>+E1 =:= +E2 [ISO]
    E1 and E2 evaluate to the same number.</desc>
</pred>

<pred>
        <id>-A===+L</id>
        <desc>-A === +L
    Same as concat(+L,-A). Note the reversed order of the
    parameters, comparing with concat/2. This is because we
    want ===/2 to be used as a kind of assignment operator.</desc>
</pred>

<pred>
        <id>concat(+L,-A)</id>
        <desc>concat(+L,-A)
    Takes the textual representations of all the terms
    in L and concatenates everything into the returned
    atom A. Sublists in L are subjected to the
    recursive application of concat/2. Example::

        ?- concat(['ole ',f(a),'Az',[[a]]],X), writeln(X).
        ole f(a)Aza
        X='ole f(a)Aza'</desc>
</pred>

<pred>
        <id>slice(+A,+Na,+Nb,-Asub)</id>
        <desc>slice(+A,+Na,+Nb,-Asub)
    Asub is the subatom of atom A that includes the characters of A in
    the closed interval defined by offsets Na and Nb. Two different
    coordinate systems are supported: (1) positive offsets are relative
    to the beginning of A; (2) negative offsets are relative to the
    ending of A. Examples::

        slice('ABC',1,2,Asub)        -->  Asub = 'A'
        slice('ABC',-2,-1,Asub)      -->  Asub = 'BC'.
        slice('ABC',2,-1,Asub)       -->  Asub = 'BC'.
        slice('ola.pl',-3,-1,'.pl')  -->  true.
        slice('ABC',1,-1,Asub)       -->  Asub = 'ABC'
        slice('ABC',2,1,Asub)        -->  Asub = ''
        slice('ABC',10,100,Asub)     -->  Asub = ''
        slice('ABC',-20,-10,Asub)    -->  Asub = ''</desc>
</pred>

<pred>
        <id>numbervars(+T,+Na,-Nz)</id>
        <desc>numbervars(+T,+Na,-Nz)
    Unifies the variables in T to terms of the form
    '$VAR'(N), with N between Na and Nz-1.
    Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>number_chars(?N,?L)</id>
        <desc>number_chars(?N,?L) [ISO]
    L is the list of characters (one-char atoms) that makes up the printed
    representation of the number N.</desc>
</pred>

<pred>
        <id>atom_chars(?A,?L)</id>
        <desc>atom_chars(?A,?L) [ISO]
    L is the list of characters (one-char atoms) that makes up the printed
    representation of the atom A.</desc>
</pred>

<pred>
        <id>number_codes(?N,?L)</id>
        <desc>number_codes(?N,?L) [ISO]
    L is the list of Unicode codes that makes up the printed
    representation of the number N.</desc>
</pred>

<pred>
        <id>atom_codes(?A,?L)</id>
        <desc>atom_codes(?A,?L) [ISO]
    L is the list of Unicode codes that makes up the printed
    representation of the atom A.</desc>
</pred>

<pred>
        <id>name(?AN,?L)</id>
        <desc>name(?AN,?L)
    L is the list of Unicode codes that makes up the printed
    representation of the atom or number AN. Note that if L can be
    seen as the representation of a number then AN becomes instanciated with
    that number. For example, name(X,[51,52,53]) returns 123 and not '123'.
    To be sure an atom is returned you use the more specific predicates
    atom_char/2 or atom_codes/2. For example, both atom_chars(X,['1','2','3'])
    and atom_codes(X,[51,52,53]) return the atom '123'.</desc>
</pred>

<pred>
        <id>term_size(_G555,_G556)</id>
</pred>

<pred>
        <id>subterm(+T1,-T2)</id>
        <desc>subterm(+T1,-T2)
    T1 is a part of T2. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>hide_par(?T1,?T2)</id>
        <desc>hide_par(?T1, ?T2)
    This predicate helps dealing with the terms generated by the
    term reader when the 'parenthesised' operator flag is active.
    More details later...</desc>
</pred>

<pred>
        <id>term_variables(+T,-L)</id>
        <desc>term_variables(+T,-L)
    L is the list of all the variables in term T. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>copy_term(L,+T1,-T2)</id>
        <desc>copy_term(L,+T1,-T2)
    T2 is a copy of term T1 in which all variables in
    list L have been replaced by new variables
    occurring nowhere else.  Handles cyclic terms well.
    Example: *copy_term([X,Y],f(A,X,Y),Z) --> Z=f(A,_45,_46).*</desc>
</pred>

<pred>
        <id>copy_term(+T1,-T2)</id>
        <desc>copy_term(+T1,-T2) [ISO]
    T2 is a copy of term T1 in which all variables have
    been replaced by new variables occurring nowhere
    else. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>cyclic_term(+T)</id>
        <desc>cyclic_term(+T)
    Succeeds if the term T is cyclic.</desc>
</pred>

<pred>
        <id>acyclic_term(+T)</id>
        <desc>acyclic_term(+T)
    Succeeds if the term T is acyclic.</desc>
</pred>

<pred>
        <id>ins_end(+T,+X,-TX)</id>
        <desc>ins_end(+T,+X,-TX)
    Term TX is the term T with the extra argument X
    inserted at the end positi</desc>
</pred>

<pred>
        <id>ins_start(+T,+X,-TX)</id>
        <desc>ins_start(+T,+X,-TX)
    Term TX is the term T with the extra argument X
    inserted at the start position. Efficient
    unidirectional predicate.</desc>
</pred>

<pred>
        <id>ins(+N,?T,?X,?TX)</id>
        <desc>ins(+N,?T,?X,?TX)
    Term TX is the term T with the extra argument X
    inserted at position N. The condition 1 &lt;= N &lt;= arity(T)+1
    must hold or the predicate fails. Bidirectional predicate.</desc>
</pred>

<pred>
        <id>arg(+N,+T,-Tn)</id>
        <desc>arg(+N,+T,-Tn) [ISO]
    Tn in the N-th argument of term T. The condition 1 &lt;= N &lt;= arity(T)
    must hold or the predicate fails.</desc>
</pred>

<pred>
        <id>functor(?T,?A,?N)</id>
        <desc>functor(?T,?A,?N) [ISO]
    T is a term with name A and arity N.</desc>
</pred>

<pred>
        <id>is_list(+T)</id>
        <desc>is_list(+T)
    T is a properly terminated list.</desc>
</pred>

<pred>
        <id>callable(+T)</id>
        <desc>callable(+T)
    T is an atom or a compound term.</desc>
</pred>

<pred>
        <id>compound(+T)</id>
        <desc>compound(+T) [ISO]
    T is a structure or a list, that is a term with arity greater than zero.</desc>
</pred>

<pred>
        <id>ground(+T)</id>
        <desc>ground(+T)
    T does not include free variables. Handles cyclic terms well.</desc>
</pred>

<pred>
        <id>atomic(+T)</id>
        <desc>atomic(+T) [ISO]
    T is an atom or a number.</desc>
</pred>

<pred>
        <id>number(+T)</id>
        <desc>number(+T) [ISO]
    T is a number (integer or float).</desc>
</pred>

<pred>
        <id>float(+T)</id>
        <desc>float(+T) [ISO]
    T is a float number.</desc>
</pred>

<pred>
        <id>integer(+T)</id>
        <desc>integer(+T) [ISO]
    T is an integer number.</desc>
</pred>

<pred>
        <id>atom(+T)</id>
        <desc>atom(+T) [ISO]
    		T is an atom.</desc>
</pred>

<pred>
        <id>nonvar(+T)</id>
        <desc>nonvar(+T) [ISO]
    T is an instantiated term.</desc>
</pred>

<pred>
        <id>var(+T)</id>
        <desc>var(+T) [ISO]
    T is an uninstantiated variable.</desc>
</pred>

<pred>
        <id>code +AFPredSpec</id>
        <desc>code +AFPredSpec
    Displays the virtual machine code for all predicates
    described by AFPredSpec. AFPredSpec can be an atom,
    a predicate indicator (Name/Arity), a comma-separated
    sequence of atoms/predicate indicators, or a list of
    atoms/predicate indicators. Example: *code a, b/4, c.*</desc>
</pred>

<pred>
        <id>nospyall</id>
        <desc>nospyall
    Removes all spy points from all predicates.</desc>
</pred>

<pred>
        <id>nospy +AFPredSpec</id>
        <desc>nospy +AFPredSpec
    Removes the spy point for the predicates given by AFPredSpec.</desc>
</pred>

<pred>
        <id>spy +AFPredSpec</id>
        <desc>spy +AFPredSpec
    Sets spy points on all predicates described by AFPredSpec.
    AFPredSpec can be an atom, a predicate indicator (Name/Arity),
    a comma-separated sequence of atoms/predicate indicators or
    a list of atoms/predicate indicators.
    All events associated with a predicate with a spy point set,
    will force the debugger to prompt the user (even if
    leashing is off). Example: *spy a, b/4, c.*</desc>
</pred>

<pred>
        <id>leash(Mode)</id>
        <desc>leash(Mode)
    Sets "leashing mode" to Mode, where Mode is one of
    the following atoms:

    - 'full'  - prompt on call, exit, next, fail
    - 'tight' - prompt on call, next, fail
    - 'half'  - prompt on call, next
    - 'loose' - prompt on call
    - 'off'   - no prompt
    - DEFAULT = 'half'

    When an event causes the debugger to display
    information, if that event is "leashed"
    then the debugger stops there to allow user to
    interact.
    The events 'redo' and 'cut' cannot be leashed.</desc>
</pred>

<pred>
        <id>debugging</id>
        <desc>debugging
    Displays information concerning the current state of
    debugger, including the list of active spy points
    and the current leashing mode.</desc>
</pred>

<pred>
        <id>current_prolog_flag(?A,-T)</id>
        <desc>current_prolog_flag(?A,-T) [ISO]
    Queries the value of flag A. Fails if the flag A is not supported.
    Can also be used to generate, through backtracking, all the supported
    Prolog flags and the corresponding values.</desc>
</pred>

<pred>
        <id>set_prolog_flag(+A,+T)</id>
        <desc>set_prolog_flag(+A,+T) [ISO]
    Sets the Prolog flag A to the value T. The goal either succeeds or
    raises an exception (because the new value is not of the type of the
    flag or because the flag is read-only).</desc>
</pred>

<pred>
        <id>flags</id>
        <desc>flags
    Shows the current status of all Prolog flags.</desc>
</pred>

<pred>
        <id>flag(+A,-To,+Tn)</id>
        <desc>flag(+A,-To,+Tn) [deprecated]
    Retro-compatibility predicate that gets/changes the value of flag A.
    The old value of the flag A is To and the new value is Tn. For boolean
    flags, it uses the values 'off' and 'on' instead of 'false' and 'true'.
        </desc>
</pred>

<pred>
        <id>flag(+A,-T)</id>
        <desc>flag(+A,-T)  [deprecated]
    Retro-compatibility predicate, almost equivalent to set_prolog_flag/2.
    The only difference is that, for boolean flags, it uses the values
    'off' and 'on' instead of 'false' and 'true'.</desc>
</pred>

<pred>
        <id>chk_floats</id>
</pred>

<pred>
        <id>floats</id>
        <desc>floats
    Shows all existing large precision floats and also information
    concerning the hash table where they are stored.</desc>
</pred>

<pred>
        <id>gcr(_G395)</id>
</pred>

<pred>
        <id>gc</id>
</pred>

<pred>
        <id>write_exception(+Exception)</id>
        <desc>write_exception(+Exception)
    Writes an exception-term in the stream 'user_error' using the the CxProlog
    format for error messages.
    On error, any built_in predicate creates an exception-term and then,
    depending on the value of the 'on_error' Prolog flag, may throw an
    exception. The format of a exception-term is as exemplified::

       error('ERROR', see/1, 'Cannot open file ''a''')
       error('TYPE ERROR', see/1, 'STREAM or FILENAME expected, found ''1''')</desc>
</pred>

<pred>
        <id>on_exception(?Pattern,+ProtectedGoal,+HandlerGoal)</id>
        <desc>on_exception(?Pattern,+ProtectedGoal,+HandlerGoal)
    This is a Quintus-Prolog compatibility predicate.
    Equivalent to
    *catch(+ProtectedGoal,?Pattern,+HandlerGoal).*
    Note the different argument order.</desc>
</pred>

<pred>
        <id>catch(+ProtectedGoal,-Exception,-StackTrace,+HandlerGoal)</id>
        <desc>catch(+ProtectedGoal,-Exception,-StackTrace,+HandlerGoal)
    Similar to catch/3 except that, if the debugger is on,
    a stack trace of the current execution environment
    is built and returned in the parameter StackTrace.
    If the debugger is off the empty list is returned.</desc>
</pred>

<pred>
        <id>catch(+ProtectedGoal,Exception, -HandlerGoal)</id>
        <desc>catch(+ProtectedGoal,-Exception,-HandlerGoal) [ISO]
    This is equivalent to ProtectedGoal, unless an exception
    is thrown while ProtectedGoal is being proved. In this
    case all the bindings made by ProtectedGoal are undone,
    like it the goal has failed, and Exception is unified with
    the term representing the exception. If the unification
    succeeds, the exception is said to have been "caught"
    and the HandlerGoal is executed, in fact replacing the
    execution of the original ProtectedGoal. If the unification
    fails, the system starts looking for an ancestor of the
    current goal that would handle the exception. If it
    cannot find any such a handler, the system activates
    a default handler that prints the exception term and,
    if the debugger is on, also prints the stack trace
    corresponding to the execution context at the point
    where the exception was raised.</desc>
</pred>

<pred>
        <id>zctx</id>
</pred>

<pred>
        <id>units</id>
        <desc>units
    Shows all the existing units.</desc>
</pred>

<pred>
        <id>current_unit(-T)</id>
        <desc>current_unit(-T)
    Generates, through backtracking, the descriptors of all the existing units.</desc>
</pred>

<pred>
        <id>unit_in_use(_G358)</id>
</pred>

<pred>
        <id>unit_spec(-U)</id>
        <desc>unit_spec(-U)
    UnitSpec is the unit designator of the current unit.</desc>
</pred>

<pred>
        <id>hcontext(-L)</id>
        <desc>hcontext(-L)
    L is the current historic context, represented as a
    list of lists of unit designators.</desc>
</pred>

<pred>
        <id>context(-L)</id>
        <desc>context(-L)
    L is the current context, represented as a list of
    unit designators.</desc>
</pred>

<pred>
        <id>abolish_all</id>
</pred>

<pred>
        <id>create_unit(+U)</id>
        <desc>create_unit(+U)
    Creates a new unit, as specified by unit designator U.
    In the case of an parametrized unit, all the parameters of U
    must be atoms, telling the name of each unit parameter.
    You probably never will need to use this predicate, which is
    used in the implementation on consult/1.</desc>
</pred>

<pred>
        <id>gclose(_G336)</id>
</pred>

<pred>
        <id>gopen(_G332)</id>
</pred>

<pred>
        <id>&lt;+G</id>
        <desc>&lt;+G
    Context restoring. Proves G in the most recently
    saved context, which is temporarily popped from
    the historic stack.</desc>
</pred>

<pred>
        <id>>+G</id>
        <desc>>+G
    Context saving. Proves G in the current context,
    after pushing the current context on the historic
    context.</desc>
</pred>

<pred>
        <id>&lt;&lt;(_G319,_G320)</id>
</pred>

<pred>
        <id>down _G315</id>
        <desc>down +G
    Context down. Proves G with the top of the
    current context popped.</desc>
</pred>

<pred>
        <id>call_on_empty_context(+G)</id>
        <desc>call_on_empty_context(+G)
    Context freeing. Proves G in the empty context.</desc>
</pred>

<pred>
        <id>>></id>
        <desc>+E1 >> +E2 [ISO]
    Integer bitwise right shift. Only applies to integers.</desc>
</pred>

<pred>
        <id>import(_G301,_G302)</id>
</pred>

<pred>
        <id>visible +FPredSpec</id>
        <desc>:- visible +FPredSpec
    This directive declares the specified predicates to be visible
    outside the current unit, enabling them to be imported into other
    units. FPredSpec can be an a predicate indicator (Name/Arity),
    a comma-separated sequence of predicate indicators or a
    list of predicate indicators. Example: *:-visible a/2, b/4, c/4.*</desc>
</pred>

<pred>
        <id>call_cleanup(+G,+Cleanup)</id>
        <desc>call_cleanup(+G, +Cleanup)
    Ensures that Cleanup is executed after the goal G has completed
    execution so that it will not resume execution anymore. By "completed
    execution" of G we mean one of the following:
    (1) G has succeeded determinately, after exhausting all its solutions;
    (2) G has failed; (3) G has raised an exception; (4) a cut in G has removed
    all the remaining alternatives for G; (5) a cut after G has removed all
    the remaining alternatives for G.
    The Cleanup goal runs deterministically (i.e. all solutions except the
    first are cut) and for side effects alone (all new variable bindings are
    discarded at the end.)
    Example: call_cleanup(process_file(S), close(S)).

call(+G,+T1)
call(+G,+T1,+T2)
call(+G,+T1,+T2,+T3)
call(+G,+T1,+T2,+T3,+T4)
call(+G,+T1,+T2,+T3,+T4,+T5)
call(+G,+T1,+T2,+T3,+T4,+T5,+T6)
call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7)
call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7,+T8)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates,
    as in the example::

      map(G,[],[]).
      map(G,[X|Xs],[Y|Ys]) :- call(G,X,Y), map(G,Xs,Ys).

    Note that the full term, containing all the arguments, is not
    actually built; the overhead would be larger if you used ins_end/3
    or =../2 to build the full term before performing the call.
    The call/* predicates also appear in other Prologs such as
    Poplog-Prolog and SWI-Prolog.</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7,+T8)</id>
        <desc>call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7,+T8)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates,
    as in the example::</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7)</id>
         <desc>call(+G,+T1,+T2,+T3,+T4,+T5,+T6,+T7)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3,+T4,+T5,+T6)</id>
         <desc>call(+G,+T1,+T2,+T3,+T4,+T5,+T6)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3,+T4,+T5)</id>
            <desc>call(+G,+T1,+T2,+T3,+T4,+T5)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3,+T4)</id>
         <desc>call(+G,+T1,+T2,+T3,+T4)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G,+T1,+T2,+T3)</id>
          <desc>call(+G,+T1,+T2,+T3)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>
<pred>
        <id>call(+G,+T1,+T2)</id>
            <desc>call(+G,+T1,+T2)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G,+T1)</id>
        <desc>call(+G,+T1)
    Proves the goal G with the extra arguments Ti added at the end.
    For example, *call(a(1),2)* is equivalent to *a(1,2)*. Also,
    *call(a,1,2)* is equivalent to *a(1,2)*. These predicates
    are very efficient when used in higher-order predicates.</desc>
</pred>

<pred>
        <id>call(+G)</id>
        <desc>call(+G) [ISO]
    Proves goal G.</desc>
</pred>

<pred>
        <id>!</id>
        <desc>! [ISO]
    Cut. When encountered as a goal, it commits the predicate where it
    occurs to the choices made since that predicate was last activated.
    The cut is local in almost every meta-predicate, like call/1, \+/1,
    once/1, etc. and also in the condition part of ->/2.
    The cut is transparent only in the meta-predicates ,/2, ;/2, and in the
    body part of ->/2.
        </desc>
</pred>

<pred>
        <id>scratch</id>
</pred>

<pred>
        <id>prompt(?Ao,?An)</id>
        <desc>prompt(?Ao, ?An)
    Gets/changes the prompt that tells the user the system is waiting
    for keyboard input. The old prompt is the atom Ao and the new prompt
    is the atom An.</desc>
</pred>

<pred>
        <id>locale</id>
</pred>

<pred>
        <id>sub_atom(+A,?Before,?Length,?After,?SubAtom)</id>
        <desc>sub_atom(+A, ?Before, ?Length, ?After, ?SubAtom) [ISO]
    SubAtom is the subatom of A of length Length with Before characters
    preceding it and After characters following. When instantiated, Length,
    Before and After are integers. Can be used as a generator using
    back-tracking.</desc>
</pred>

<pred>
        <id>atom_concat(?A1,?A2,+A3)</id>
        <desc>atom_concat(+A1,+A2,-A3) [ISO]; atom_concat(?A1,?A2,+A3) [ISO]
    A3 is the concatenation of atoms A1 and A2. If A3  is instantiated then
    all of its decompositions can be obtained using back-tracking.
        </desc>
</pred>

<pred>
        <id>atom_length(+A,?N)</id>
        <desc>atom_length(+A,?N) [ISO]
    N is the length of atom A.</desc>
</pred>

<pred>
        <id>current_atom(?D)</id>
        <desc>current_atom(?D)
    Generates, through backtracking, all the existing atoms.</desc>
</pred>

<pred>
        <id>atoms</id>
        <desc>atoms
    Shows all existing atoms and also information
    concerning the hash table where they are stored.</desc>
</pred>

<pred>
        <id>deleted(_G180)</id>
</pred>

<pred>
        <id>basic_gc</id>
</pred>

<pred>
        <id>mshow(_G174)</id>
</pred>

<pred>
        <id>host_speed(-N)</id>
        <desc>host_speed(-N)
    Evaluates the speed of the host machine. Faster
    machines produce larger numbers. The result is always larger than 0.
    Examples:

    - MacPlus --> 2;
    - Celeron/433 --> 450.
    - PentiumIII-M/700 --> 900.

    Of course the result provides only a rough indication. Also the result
    may vary somewhat with the version of CxProlog being used.</desc>
</pred>

<pred>
        <id>op_flag(+Name,+A,-To,+Tn)</id>
        <desc>op_flag(+Name,+A,-To,+Tn)
    Gets or changes the value of the operator flag A for the operator
    named Name. The old value of A is To and the new value
    is Tn.</desc>
</pred>

<pred>
        <id>op_flag(+Name,+A,-T)</id>
        <desc>op_flag(+Name,+A,-T)
    Queries the value of the operator flag A for the operator
    named Name.</desc>
</pred>

<pred>
        <id>ops</id>
        <desc>ops
    Shows details about the currently defined operators.</desc>
</pred>

<pred>
        <id>reset_ops</id>
        <desc>reset_ops
    Resets all the operators to their initial state.</desc>
</pred>

<pred>
        <id>op(+Prec,+Type,+Name)</id>
        <desc>op(+Prec,+Type,+Name) [ISO]
    Declares a operator named Name of type Type and
    precedence Prec. Name can be a single operator
    name or a list of operator names. Type is one of
    the following atoms: fx, fy, xf, yf, xfx, xfy, yfx,
    yfy. Prec is one integer in the range 0..1200,
    higher values indicating lower precedence. "0" is a special
    precedence that cancels one active interpretation of the
    operator as follows::

     - cancels the prefix interpretation if Type is fx or fy
     - cancels the infix interpretation if Type is xfx, xfy or yfx
     - cancels the postfix interpretation if Type is xf or yf.</desc>
</pred>

<pred>
        <id>error(+T)</id>
        <desc>error(+T)
    Issues one error message in the CxProlog standard format and
    then calls abort/0. The message is written in the stream
    'user_error'. The main part of the message consists in the textual
    representation of T unless T is a list. In it is a list, it is
    filtered through concat/2 before the result is printed.</desc>
</pred>

<pred>
        <id>warning(+T)</id>
        <desc>warning(+T)
    Issues one warning message in the CxProlog standard format.
    The message is written in the stream 'user_error'. The main part
    of the message consists in the textual representation of T unless T
    is a list. In it is a list, it is filtered through concat/2 before the
    result is printed.</desc>
</pred>

<pred>
        <id>apply(+A,+L)</id>
        <desc>apply(+A,+L)
    Proves a modified goal G with extra arguments added at the end.
    The extra arguments are the terms in the list L. For example,
    *apply(a,[1,2])* is equivalent to *a(1,2)*. This predicate also
    exists in SWI-Prolog.</desc>
</pred>

<pred>
        <id>-N is +E</id>
        <desc>-N is +E [ISO]
    Evaluates Exp as an arithmetic expression and unifies
    the result with N. The result of the evaluation is
    automatically converted to an integral value
    whenever its decimal part is zero or almost zero.</desc>
</pred>

<pred>
        <id>restart</id>
        <desc>restart
    Same as abort/0.</desc>
</pred>

<pred>
        <id>abort</id>
        <desc>abort
    Aborts the CxProlog execution and restarts the top level. The execution
    stacks are cleared, but the internal database remains unchanged.</desc>
</pred>

<pred>
        <id>exit</id>
        <desc>exit
    Exits from CxProlog, displaying no message.</desc>
</pred>

<pred>
        <id>halt</id>
        <desc>halt [ISO]
    Terminates CxProlog execution displaying the message
    "CxProlog halted".</desc>
</pred>

<pred>
        <id>repeat</id>
        <desc>repeat [ISO]
    Succeeds repeatedly on backtracking.</desc>
</pred>

<pred>
        <id>false</id>
        <desc>false
    Same as fail.</desc>
</pred>

<pred>
        <id>fail</id>
        <desc>fail [ISO]
    Fails.</desc>
</pred>

<pred>
        <id>true</id>
        <desc>true [ISO]
    Succeeds.</desc>
</pred>

<pred>
        <id>raise_exception(+Exception)</id>
        <desc>raise_exception(+Exception)
    This is a Quintus-Prolog compatibility predicate.
    Identical to throw/1.</desc>
</pred>

<pred>
        <id>throw(+ExceptionTerm)</id>
        <desc>throw(+ExceptionTerm) [ISO]
    Explicitly throws an exception. ExceptionTerm can be any
    term except a free variable.

    **Note:** All non-fatal errors that might arise during the
    execution of programs manifest themselves by throwing
    exceptions.</desc>
</pred>

<pred>
        <id>-></id>
        <desc>+G1->+G2 [ISO]
    Same as *(G1->G2;false)*. But if the 'compatible_if_then'
    Prolog flag is 'false', it becomes equivalent to *(G1->G2;true)*
    which is more sound logically.</desc>
</pred>

<pred>
        <id>,</id>
        <desc>+G1,+G2 [ISO]
    Conjunction. Proves G1 and G2.</desc>
</pred>

<pred>
        <id>;</id>
        <desc>+G1;+G2 [ISO]
    Disjunction. Proves G1 or G2.</desc>
</pred>
</predicates>
